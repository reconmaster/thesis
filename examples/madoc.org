# -*- fill-column: 80; -*-

#+TITLE: Complementing the OpenPGP Web of Trust with Linked Identities

#+OPTIONS: toc:nil creator:nil H:4 num:4 ':t ^:{}

#+LaTeX_CLASS: masterthesis

# document requires the org-export-remove-prelim-headlines hook.  alternatively,
# just remove all headlines which have a :prelim: tag and promote their
# children :prelim:

* Latex Headers                                                      :prelim:

#+LaTeX_HEADER: \newcommand{\mttitle}{Complementing the OpenPGP Web of Trust with Linked Identities}
#+LaTeX_HEADER: \newcommand{\mtauthor}{Vincent Breitmoser}
#+LaTeX_HEADER: \newcommand{\mtinstitut}{Institut für Betriebssysteme und~Rechnerverbund}

#+LATEX_HEADER: \subject{Master's Thesis}
#+LATEX_HEADER: \publishers{\textbf{Institute of Operating Systems and Computer Networks\\Prof.\,Dr.-Ing.\,Lars Wolf}\\ \vspace*{2em} Supervisor:\\ Dominik Schürmann,\,M.\,Sc.}
#+LaTeX_HEADER: \title{\mttitle}
#+LaTeX_HEADER: \author{\mtauthor}
#+LaTeX_HEADER: \logo{\mtinstitut}

#+LaTeX_HEADER: \hyphenation{Sy-man-tec}
#+LaTeX_HEADER: \hyphenation{Open-PGP}
#+LaTeX_HEADER: \hyphenation{Linked-Identity}
#+LaTeX_HEADER: \hyphenation{Raw-Linked-Identity}
#+LaTeX_HEADER: \hyphenation{Linked-Token-Resource}
#+LaTeX_HEADER: \hyphenation{Linked-Attribute}
#+LaTeX_HEADER: \hyphenation{Open-Key-chain}
#+LaTeX_HEADER: \hyphenation{packets}

#+LaTeX_HEADER: \widowpenalty450
#+LaTeX_HEADER: \clubpenalty450

#+LATEX_HEADER: \usepackage{wrapfig}
#+LATEX_HEADER: \usepackage[plain]{fancyref}
#+LATEX_HEADER: \usepackage{subcaption}
#+LATEX_HEADER: \usepackage{backnaur}
#+LATEX_HEADER: \usepackage{xparse}
#+LATEX_HEADER: \usepackage{newfloat}
#+LATEX_HEADER: \usepackage{rotating}
#+LATEX_HEADER: \usepackage{adjustbox}
#+LATEX_HEADER: \usepackage{tikz}
#+LATEX_HEADER: \DeclareFloatingEnvironment[
#+LATEX_HEADER:     fileext=los,
#+LATEX_HEADER:     listname=List of Examples,
#+LATEX_HEADER:     name=Example,
#+LATEX_HEADER:     placement=tbph,
#+LATEX_HEADER:     within=chapter,
#+LATEX_HEADER: ]{example}

#+LATEX_HEADER: \newcommand*{\fancyrefexlabelprefix}{ex}
#+LATEX_HEADER: \fancyrefaddcaptions{english}{%
#+LATEX_HEADER:   \providecommand*{\frefexname}{example}%
#+LATEX_HEADER:   \providecommand*{\Frefexname}{Example}%
#+LATEX_HEADER: }
#+LATEX_HEADER: \frefformat{plain}{\fancyrefexlabelprefix}{\frefexname\fancyrefdefaultspacing#1}
#+LATEX_HEADER: \Frefformat{plain}{\fancyrefexlabelprefix}{\Frefexname\fancyrefdefaultspacing#1}
#+LATEX_HEADER: \frefformat{vario}{\fancyrefexlabelprefix}{%
#+LATEX_HEADER:   \frefexname\fancyrefdefaultspacing#1#3%
#+LATEX_HEADER: }
#+LATEX_HEADER: \Frefformat{vario}{\fancyrefexlabelprefix}{%
#+LATEX_HEADER:   \Frefexname\fancyrefdefaultspacing#1#3%
#+LATEX_HEADER: }

# rotation for
#+LATEX_HEADER: \newcommand{\rot}[1]{\multicolumn{1}{c}{\adjustbox{angle=50,lap=\width-1em}{#1}}}

#+LATEX_HEADER: \bibliography{rfc}

* Statement of Originality                                           :prelim:

#+BEGIN_LATEX
\frontmatter

\cleardoublepage

% statement of originality
\thispagestyle{plain} % no header
\vspace*{7cm}
\centerline{\bfseries Statement of Originality}
\vspace*{1em}
\noindent
This thesis has been performed independently with the support of my supervisor/s.
To the best of the author's knowledge, this thesis contains no material previously
published or written by another person except where due reference is made in the text.

\par
  \bigskip\noindent Braunschweig, \today \par
  \vspace*{10mm}
  \hfill\hrulefill

\cleardoublepage
#+END_LATEX

* Abstract                                                           :prelim:

# abstract
\thispagestyle{plain}
\centerline{\bfseries Abstract}
\vspace*{1em}
\noindent

The present master thesis introduces the concept of Linked Identities for
establishing authentication of OpenPGP keys by linking them with a resource on
the internet by mutual proof of control.  To this end, a URI scheme is
introduced which encodes a claim of control over a resource, together with a
format for a token to be placed at the referenced site for proof.  To store a
URI of this type as part of an OpenPGP key, a new type of User Attribute is also
introduced.  Both of these concepts are standardized in the form of two Internet
Drafts, formally extending the OpenPGP standard RFC 4880.  As a concrete
implementation, support for the proposed Linked Attribute is added to
OpenKeychain, a fully compatible OpenPGP implementation for Android.  The added
features include creation, verification and certification of Linked Attributes,
complete with a user interface suitable for consumer use.  The proposed concept
and implementation are then evaluated in three ways.  First, by comparing the
approach to that of Keybase in terms of technical features.  Second, through
examination of the additional attack surface added by the use of Linked
Identities, compared to established authentication methods.  Finally, a user
study is conducted to evaluate the perceived trustworthiness of the approach
when used for authentication, as well as stability and usability of the user
interface created in OpenKeychain.

\cleardoublepage

# kurzfassung
\thispagestyle{plain}
\centerline{\bfseries Kurzfassung}
\vspace*{1em}
\noindent

Die vorliegende Masterarbeit führt das Konzept von Linked Identities ein,
welches verwendet wird um OpenPGP Keys zu authentisieren, indem sie mit einer
Resource im Internet durch wechselseitigen Kontrollbeweis verknüpft werden.  Zu
diesem Zweck wird zunächst ein URI Schema eingeführt, welches einen
entsprechende Behauptung en\-co\-diert, zusammen mit einem Format für ein Token,
das an der referenzierten Addresse veröffentliche wird und damit als Beweis der
Behauptung dient.  Um eine derartige URI als Teil eines OpenPGP Keys zu
speichern wird außerdem ein neuer Typ des OpenPGP User Attribut Pakets
entworfen.  Beide Konzepte werden standardisiert in Form von zwei Internet
Drafts, die den OpenPGP Standard RFC 4880 formal erweitern.  Als konkrete
Implementierung wird Unterstützung für das vorgestellte Linked Attribute feature
zu OpenKeychain hinzugefügt, einer vollständig OpenPGP-kompatiblen
Implementierung für Android.  Die hinzugefügten Features enthalten Erzeugung,
Verifikation und Beglaubigung von Linked Attributes, zusammen mit einer für
Endnutzer geeigneten Nutzeroberfläche.  Die vorgestellten Konzepte und
Implementierung werden danach auf drei Arten ausgewertet.  Zunächst wird der
Ansatz von Linked Attributes mit der Plattform Keybase in technischen
Gesichtspunkten verglichen.  Desweiteren wird die zusätzliche Angriffsfläche,
die die Nutzung von Linked Identities erzeugt, verglichen mit etablierten
Authentisierungsmethoden.  Letztlich wird eine Nutzerstudie durchgeführt, um
sowohl das wahrgenommene Vertrauen, als auch die Stabilität und Nutzbarkeit des
imlementierten Nutzeroberfläche in OpenKeychain zu erfassen.

\cleardoublepage

* Table of Contents                                                  :prelim:

\tableofcontents
\cleardoublepage

# \listoffigures
# \cleardoublepage

# \listoftables
# \cleardoublepage

# arabic numbering
\mainmatter

* Introduction

Ever since Diffie and Hellman published their seminal paper "New Directions in
Cryptography" \cite{diffie1976new}, public-key cryptography has become an
integral part of the security aspect of today's communication technologies.  By
using different keys for encryption and decryption of messages, the exchange of
keys used for secure communication with public-key cryptography needs only be
transferred over a channel which needs to be authenticated, rather than
confidential as required in "conventional", or symmetric cryptography.  The weak
point of public-key encryption lies in the means of obtaining an intended
recipient's public key over an authenticated channel: If an adversary can
substitute the obtained key for one of their own during retrieval, they will be
able to perform a Man-In-The-Middle attack on any communication intended for the
substituted public key by pretending to be the communication partner to both
parties, negating the communication's cryptographic properties.

The generally accepted requirements for an authenticated channel of digital
communication have been tied to the cryptographic property of authentication,
such as those established between keys by use of digital signatures.  For
personal communication, authenticated channels are bootstrapped from personal
identification, either by a meeting between communication participants, or
indirectly by identifying to a trusted third party as provided by a Public-Key
Infrastructure.

In the documentary Citizenfour \cite{poitras2014citizenfour}, it is revealed
that Edward Snowden had a third party post the fingerprint of Laura Poitras'
OpenPGP key on Twitter as a means of authentication \cite{micahsmuggle}.  This
serves as a great reminder that channels of authentication are not required to
be confidential or direct, they need only provide confidence that a user is who
they claim to be.  With the ever rising importance of the internet in everyday
social life, a person's presentation on social media websites is starting to
become a relevant part of a person's identity, and users are quite invested in
protecting the integrity of their online profiles \cite{kietzmann2011social}.  A
profile on social media is perceived as a very personal thing, which leads to
the idea of using them for authentication.  In early 2014, the
Keybase[fn:keybase] platform launched in an alpha stage, which offers creation
and distribution of proofs of identity for OpenPGP keys by various means of
social media and other online resources.

The present thesis generalizes this feature set to the concept of Linked
Identities, and consequently introduces Linked Attributes as an extension to the
OpenPGP standard RFC 4880 \cite{rfc4880}.  The use of Linked Attributes allows
OpenPGP keys to contain identities which associate the key itself with resources
on the internet, providing mutual cryptographic proof of control.  The presented
extension is fully compatible with compliant implementations of the OpenPGP
standard, complements established mechanisms for authentication like the Web of
Trust (WoT), and makes use of the established keyserver infrastructure as a
distribution platform.  The proposed standards for Linked Attributes have also
been implemented into the OpenKeychain OpenPGP implementation for Android.

** Overview

The remainder of this thesis is split into five chapters.  In the Background
chapter (\Fref{chap:background}), an overview is given over relevant
technologies and standards, and some of terminology is introduced for accurate
discourse in later chapters.  The chapter on Linked Identities
(\Fref{chap:lids}) introduces the concept of Linked Identities by establishing
the relevant design requirements, an examination the Keybase implementation, and
finally by describing the two Internet Draft standards written for this thesis.
The chapter on Implementation (\Fref{chap:implementation}) gives a description
of the implementation created for this thesis, outlining its code structure,
user interface, and relevant design decisions.  In the Evaluation
(\Fref{chap:evaluation}), Linked Identities are evaluated in concept by
contrasting Linked Attributes with Keybase and examining the attack surface
introduced by the use of Linked Attributes, and in practice by conducting a user
study. The final Conclusion chapter (\Fref{chap:conclusion}) gives a concluding
resumé over the results of the thesis, and lists a number of issues left open,
in the implementation and otherwise.

* Background
<<chap:background>>

In this chapter, we both provide the reader with technical background on
relevant technologies, and introduce a number of concepts and terminology which
will be used for consistency throughout the document.

** Public-Key Cryptography
Asymmetric or public-key cryptography is a branch of cryptography which eschews
the use of a priori shared secrets in favor of pairs of public and secret keys.
Generally, a public and secret keys are generated together as a pair, where the
public key is then publicly shared, while the secret key is kept by its owner.
The public key can then be used to encrypt messages in a way that can only be
decrypted with knowledge of the secret key.  Various public-key encryption
schemes exist, although most of them are academic in nature.  The most renown
such scheme is RSA\cite{rivest1978method}, which is currently widely deployed in
various security protocols.  More recently, Elliptic-Curve Cryptosystems (ECC)
have seen a rise in popularity due to their reduced key size, speed, and
security properties \cite{hankerson2004guide}.

The core property of a public key compared to a shared secret is that it can be
publicly shared, which alleviates the need for confidentiality during exchange
of keys between communication partners\cite{diffie1976new}.  It does not,
however, have any effect on the need for authentication.  A fundamental insight
about asymmetric cryptography is that all provided cryptographic properties
depend on the authenticity of employed public key material.  This weakness can
be exploited as a so-called /Man-in-the-Middle/ (MitM) attack: If an attacker is
able to substitute the public key used to encrypt a message for one of their
own, for example during retrieval or on storage, they can then intercept the
message, decrypt it, re-encrypt it with the actual public key and relay it to
the recipient.

Confidentiality is a property that has fairly technical semantics, that is, the
cleartext of a message must be strictly unobtainable for everyone who is not an
intended recipient.  Authentication on the other hand is more involved, and
there are various approaches to it.  Authentication in general has been a topic
of much research, and remains one of the largest attack surfaces of
communication protocols which rely on asymmetric cryptography.

This thesis focuses on the authentication aspect of asymmetric cryptography
entirely.  Other characteristics including cryptographic properties like
confidentiality and non-repudiability, or specific choices of algorithms and
cipher suites are out of scope.

# The key difference between public-key encryption schemes is the mathematical
# problem they base their security properties on. in case of RSA this is
# factorization.

** Authentication in Personal Communication

To establish secure communication between two participants, it is required to
have an authenticated exchange of public keys.  In this section, we define a
number of terms to aid precise discourse on the subject, then look at
established solutions outside of OpenPGP for later comparison.

*** Trust Anchors, Nodes and Links

Authentication in general is the process of determining whether someone or
something is who or what they claim to be.  This process depends on the type of
claim; the specific claim made by someone or something can be various things,
and serves as a trust anchor in the authentication process.  There are claims
for which proof is easily constructed, for example someone can prove that they
possess the secret to some public key by signing some data with it.  This is
only helpful though for an identity which is defined by its public key.

More precisely, a /trust anchor/ is an entity for which trust is assumed, rather
than derived \cite{linn2000trust}.  What sort of trust anchors are accepted in a
given protocol or situation can differ depending on desired level of security,
knowledge of underlying concepts, or even feeling towards certain protocols or
technology.  In personal communication in particular, the choice of trust
anchors for authentication is very much subject to personal opinion.

#+BEGIN_figure
    \centering
    \includegraphics[width=0.80\textwidth]{images/trust-anchorlinknode}
    \caption{Trust Anchor, Link and Node} \label{fig:trust-aln}
#+END_figure

We generalize here the concept of trust anchors and chains to trust nodes and
links.  A /trust node/ is an abstract entity with the defining properties that
it can be uniquely identified, and have trust links with other trust nodes
(cf. \Fref{fig:trust-aln}).  A /trust link/ is an abstract expression of trust
by one trust node towards another.  Examples of trust nodes are trust anchors,
keys, certificates, and any other entities capable of expressing trust towards
other trust nodes.  Examples of trust links are persons who identify a key as
their own by stating its fingerprint, and also certificates, or rather their
incorporated expression of trust towards something else.

Trust links come in two varieties, weak and strong.  A /weak trust link/
expresses trust in the identity of a trust node, i.e., that another node is
known to the issuing trust node by the identifier used in the trust link.  A
/strong trust link/ makes the same statement, but additionally expresses trust
in all trust links from the referred trust node.  This latter type is mostly
used in trust links towards trust nodes which are also controlled by the issuer,
for instance a user will have a strong trust link towards their own secret keys.
Unspecific use of the term trust link always implies a weak trust link.

\clearpage

Not every trust link is inherently verifiable, and similar to trust anchors, the
trust in a trust link may depend on a user's perspective.  In case of
certificates, this merely means they need to trust in the validity of the
underlying algorithm.  For other types of trust links, like claim of control
over a keyring, a user may have other requirements to trust in the claim, for
instance concerning the uniqueness properties of the identifier used to refer to
the trust node.

Trust links are also unidirectional, if a trust node expresses trust towards
another this bears no implications on a possible trust link from the trusted to
the trusting node.  This is of little importance for many types of trust links
as there is nothing, for instance, to gain from expressing trust towards a key a
user does not actually control or trust, but it does bear significance for the
case of Linked Identities.

*** Trust Decisions

The lack of universally accepted trust links moves the problem of
authentication, especially for the use case of personal communication, into the
realm of trust decisions.  "Trust" in the general sense is a complex concept,
and trust management is an important component of network security
\cite{blaze1996decentralized}.  Particular interpretations of trust vary
strongly or sometimes even subtly among different use cases and fields of
research.

We use a slightly simplified variant of the term /trust decision/ as defined by
Ruohomaa et al. \cite{ruohomaa2005trust}, and adapt it for the above definition
of trust links: A /trust decision/ is a decision which involves trust, more
specifically, it is a decision which is in some way based on a subjective
measure of "trust" and has no definite answer.  This can be the case due to a
lack of information at the time the decision is made, or even because there is
no correct answer at any time.  Still, trust decisions can be reasoned about,
supported by evidence, and weighed against practicality.  In the scope of this
document, trust decisions made by a user exclusively concern whether or not they
trust the expression of trust made by a trust link.

Depending on the identifiers available for trust nodes involved, a trust
decision can often be documented and shared in a verifiable way by means of a
certification.  When used with strong trust links, this makes it possible to
flexibly delegate trust decisions to trust nodes with already established trust.
This transitive sort of trust can be chained arbitrarily, forming trust paths.

**** Relation to Chains of Trust

The concept of trust nodes and links is a generalization of chains of trust.
The term /chain of trust/ is used in literature \cite{linn2000trust} to refer
precisely to transitive trust decisions built entirely from certificates.  We
refer to transitive connections of trust nodes and links as trust paths, to
avoid ambiguity of terms and stay consistent with graph terminology.

*** Trust Models and Public-Key Infrastructures
<<sec:trust-pki>>

# pull up widow line
\enlargethispage{\baselineskip}

To establish a trust path between two communication participants, there is a
large number of different approaches.  While these approaches can vary in many
ways, the key difference usually lies the trust decisions required from the
user.

A /Public-Key Infrastructure/ (PKI) is a general concept of how keys can be
exchanged between users with a number of assertions.  Particular PKIs usually
involve more or less strictly defined sets of processes, policies, algorithms
and software to provide at least authenticity of public keys in a unique
namespace, and sometimes non-repudiation.  PKI procedures can involve human
interaction, assertions provided may consequently be of partial cryptographic
nature only.

One key distinctive feature of a PKI is its precise definition of trust anchors.
A trust anchor in a PKI is any type of authoritative entity deemed ultimately
trustworthy in the model, either established by the model itself, institutions
within the model, or decided upon by the user at some point.  A PKI's particular
notion of trust anchors directly affects the granularity and complexity of trust
decisions required from the user or (if applicable) maintaining personnel in a
given PKI.

A number of PKIs have emerged to solve the general problem of authentication.
In this section, we give a general overview over the most widely deployed ones,
albeit in a very condensed way.

**** Trust On First Use
<<sec:tofu>>

The /Trust on First Use/ trust model, also known as TOFU, is not a PKI but
rather the prototypical optimistic trust model \cite{wendlandt2008perspectives}.
It has no concept of trust anchors, instead public keys are exchanged between
communication partners during initial setup of their first communication, and
(as the name suggests) immediately considered trustworthy to use for secure
communication.  After initial exchange the keys are stored by both participants
and re-used for all later communication.  This process requires no user
interaction, providing a very seamless user experience.

There are no strict assertions made for authentication at any point, but if the
key of either participant changes, the other participant is notified of this
event.  This means that an attacker who performed a successful MitM attack
during initial exchange of keys would have to intercept all subsequent
communication or risk being exposed when a change of keys happens which isn't
initiated by one of the participants.  Authentication at a later point is still
an option, to retroactively assert that communication has not been intercepted.

This model trades somewhat weaker initial authentication properties for
considerably reduced complexity compared to other models.  Since known keys are
stored only locally, there is no need for certifications or trust paths, and
user interaction is rarely required.  Although this model offers no guarantees
on authentication, an attack via MitM has a very high risk of being exposed at
some point.  This is obviously not an acceptable premise for communication which
has no tolerance for leaks of information or which are only short term, but it
is arguably good enough for most personal communication needs.

The TOFU trust model is prominently used for server authentication in the SSH
protocol \cite{rfc4251}, and has also become more popular in messaging
applications in recent years, most notably TextSecure[fn:textsecure].

**** X.509
<<sec:x509>>

#+BEGIN_figure
    \centering
    \includegraphics[width=0.8\textwidth]{images/ca-pki}
    \caption{The X.509 trust model} \label{fig:ca-pki}
#+END_figure

The X.509 \cite{rfc5280} trust model defines /Certificate Authorities/ (CAs) as
trust anchors in a strict hierarchical system.  As depicted in
\Fref{fig:ca-pki}, trust decisions are delegated by the User to a Maintainer of
a fixed list of CAs known as "Root CAs".  These Maintainers are usually vendors
of applications (e.g., browsers) or operating systems, and maintenance of the
list involves a complex infrastructure of standards, policies, and accreditation
to determine eligibility for each CA.  Every Trustee is required to have their
identity verified by a CA to obtain a certificate for their key which is signed
by the "root certificate" owned by a CA.  A communication partner is deemed
trustworthy exactly when their public key has a chain of trust, i.e., verifiable
(weak) trust links from the root certificate of any trusted CA to their own
public key.

This model is most prominently used for secure communication between user agents
and servers, including HTTP and SMTP, by adding the TLS protocol \cite{rfc6176}
as a layer below the actual protocol used for communication.  This is commonly
indicated by an 'S' suffixed to the protocol name, such as HTTPS or SMTPS.  For
the e-mail use case, the X.509 trust model is deployed on a relatively large
scale as the Secure/Multipurpose Internet Mail Extensions (S/MIME) standard
\cite{rfc5751}; and unlike OpenPGP based security, many widely used e-mail
clients including Microsoft Outlook, Mozilla Thunderbird, and Apple Mail come
with built-in support for S/MIME.

Since certification in this model is a commercial service offered by CAs, this
trust model is employed for e-mail communication almost exclusively by business
customers.

Although the X.509 PKI has several problems \cite{gerck2000overview}, it works
well enough and is an integral part of the current shape of the internet.

**** Web of Trust

The /Web of Trust/ is a complex, user-centric trust model implemented on top of
OpenPGP.  As a point of focus of this thesis, it is discussed in detail in
\Fref{sec:wot}.

** The OpenPGP Standard

The /OpenPGP/ standard is an open standard for (primarily) asymmetrically
encrypted communication based on the original PGP (Pretty Good Privacy) format,
which was first invented by Phil Zimmermann in 1991
\cite{Zimmermann:1995:OPU:202735}.  It has since been reworked as an open
standard by the OpenPGP IETF working group, most recently published in November
2007 as RFC 4880 "OpenPGP Message Format" \cite{rfc4880}.  This latest revision
specifies version 4 of the message exchange format.  Since all previous versions
are at this point of negligible importance, the OpenPGP format referred to in
this document means version 4 exclusively.

The standard describes a data exchange format which covers a relatively large
area of functionality including digital signatures, encryption, compression, key
management and certificate services.  To provide the reader with enough
information for understanding the extension proposed in this thesis, we will
reproduce parts of the specification in an abridged way.

*** Binary Data Format

The OpenPGP standard specifies a unified binary format with a very flexible,
packet-based structure for both key data and communication.  Since this thesis
focuses on the authentication aspects of OpenPGP only, large parts of the
standard, particularly those parts concerned with communication rather than keys
and identities, are out of scope of this document.

# tags https://tools.ietf.org/html/rfc4880#page-17
In the packet specification, each packet consists of a header which includes a
packet tag and length, which specify the length of data contained in the packet
and its type by a packet tag.  There are 20 different tags available, 9 of which
relate to keys and 8 to communication, the rest are reserved or obsolete.  At
the point of this writing, no extensions to the RFC or notable de facto
standards exist which include new packet types.

**** Key Packets (Tags 5, 6, 7, 14)

# key packets https://tools.ietf.org/html/rfc4880#page-40
/Public/ and /secret keys/ are contained in one of four variants of key packets,
depending on their status as either master or subkey, and whether they include
the private part or public only.  All variants include exactly a creation
timestamp, the public-key algorithm identifier, an algorithm-specific public
part, and in case of secret key packets, the algorithm-specific secret part.
The algorithm-specific part depends, as the name implies, on the key's type of
algorithm, this is commonly a number of Multi-Precision Integers (see
\Fref{sec:openpgp-algos}).

**** Identity Packets (Tags 13 and 19)
<<sec:id-packets>>

# user id and user attribute packet https://tools.ietf.org/html/rfc4880#page-48
There are two types of packets which contain identities: User Id packets
(tag 13) and User Attribute packets (tag 19), referred to as /identity packets/.

A /User ID/ packet contains a UTF-8 encoded string, which holds the name and
e-mail address of the owner of a key, formatted as per RFC 2822 \cite{rfc2822}.
A common misconception is that this packet contains the name and mail address by
convention only.  In fact, the RFC states that the intended content is indeed a
name and address, leaving only the format up to convention.

# pull up widow line
\enlargethispage{\baselineskip}

The second type of identity packet is the /User Attribute/, which can contain
any number of user attribute subpackets.  The only defined type of such
subpackets is JPEG (subpacket tag 1), which as its name suggests contains an
image in JPEG File Interchange Format (JFIF).  Both packets are purely
containers for their data and gain cryptographic meaning only when accompanied
by signature packets.

**** Signature Packet (Tag 2)

# signature https://tools.ietf.org/html/rfc4880#page-19
A particularly important packet is the /signature packet/ (tag 2), which
describes an association between a public key and any sort of data backed by a
digital signature.  A signature is parameterized by a hashing algorithm and a
public key algorithm, where the former specifies the algorithm used for
calculating a hash digest over the data that should be signed, and the latter
specifies the one used for creating the digital signature over this hash.

There are several subtypes of this packet indicating the type of associated
data, such as binary or text documents for detached signatures and other packets
like public keys or User IDs if the signature is part of a key.  The subtypes
also define the actual statement of the signature, which is only loosely defined
for signatures made on text documents, and more thoroughly for signatures over
other OpenPGP packets, including in particular types to bind data to the primary
key or revoke earlier such statements.

The most relevant types for this document are those with type ids 0x10 through
0x13, which are a set of signature packets for "certification of a User ID and
Public-Key packet", which all bind a User ID (or User Attribute, see above)
packet to an OpenPGP key if made by the primary key (called a /self-signature/),
or certify this identity as correct if made by the primary key of a different
OpenPGP key.  The types differ in their degree of assertion, where 0x10 is a
"generic" signature which makes no statement about how well the identity was
checked, and the types 0x11 to 0x13 which are "no", "casual", and "positive"
certification respectively.

The hashed-over data may include one or more subpackets, which are also included
with the signature and bear additional information.  Types of subpackets are
creation and expiry timestamps of the signature, embedded signatures, notation
data and many others.  A signature must always include at least a creation
timestamp subpacket.  Subpackets in self-signatures are used to convey
preferences the OpenPGP key in a signed way, such as preferred algorithms for
hashing or encryption, preferred keyserver, or indication of supported features.

It is also worth mentioning that a signature does not usually contain any kind
of reference to the data it signs, so this connection must be made from the
context it appears in.

*** Fingerprints

The /fingerprint/ of a version 4 OpenPGP key is a 160-bit SHA-1 hash over the
public key material and creation date of a key, plus some static bytes (RFC
4880, Section 12.2), which uniquely identifies any OpenPGP primary key or
subkey.  The fingerprint of the primary key is also used to identify an OpenPGP
key as a whole, although each subkey also has their own unambiguous fingerprint.
Use of the term fingerprint in this document will always refer to the entire
key, i.e., the fingerprint of the primary key.

Although others are possible, the established human-readable representation of
fingerprints is a string of 40 hexadecimal characters.

**** Key IDs
<<sec:key-ids>>

Derived from the fingerprint are the /Long Key ID/ and /Short Key ID/, which are
the last 8 or 4 bytes of the fingerprint, respectively.  Both are, like
fingerprints, displayed as hexadecimal strings of 16 or 8 characters lengths,
Short Key IDs are often indicated by a leading "0x".  They are essentially used
for the same purposes as fingerprints, which is identification of a key, but
strike a different compromise between human-meaningful and secure by sacrificing
24 or 32 characters of uniqueness for brevity.

Due to their short length, Key IDs are vulnerable to preimage or collision
attacks.  Since the creation date timestamp in a fingerprint can be almost
freely chosen, generating distinct keys takes almost no time, making the search
speed for hash collisions equal to that of a general truncated SHA-1 sum.  This
makes collisions easily achievable for Long Key IDs \cite{coruus}, and preimages
almost trivially achievable for Short Key IDs on modern processors
\cite{evil32}.  There is agreement that Short Key IDs should no longer be used
for any purpose , and use of Long Key IDs has been a matter of dispute in recent
years \cite{dkgkeyids}.

*** Transferable public keys
<<sec:transferable-keys>>

# Primary-Key
#    [Revocation Self Signature]
#    [Direct Key Signature...]
#     User ID [Signature ...]
#    [User ID [Signature ...] ...]
#    [User Attribute [Signature ...] ...]
#    [[Subkey [Binding-Signature-Revocation]
#            Primary-Key-Binding-Signature] ...]

# transferable keys https://tools.ietf.org/html/rfc4880#page-71
A transferable OpenPGP key is a series of related packets in a specific
structure, as illustrated in \Fref{fig:trans-pubkey}.  This structure is the
same for public and secret keys, only differing in the packet types for key
data.  This key structure is necessarily rigid since it encodes information
about how the signatures are related to data packets, which as mentioned above
is not part of the signatures themselves.  A key essentially consists of three
distinct parts:
\begin{wrapfigure}{l}{0.41\textwidth}
  \centering
  \includegraphics[width=0.40\textwidth]{images/transferable-key}
  \caption{Transferable Public Key} \label{fig:trans-pubkey}
  \vspace{-1cm}
\end{wrapfigure}
1) It begins with a master key packet (tag 5), optionally followed by a
   revocation and any number of direct key signatures (tag 2, see below).
2) There must be one or more groups of one User ID packet (tag 13) followed by
   any number of related signatures (tag 2, see below), plus any number of
   similar groups but with user attribute rather than User ID packets (tag 14).
3) Any number of subkeys, each followed by a subkey binding signature, and
   optionally a subkey binding revocation.

To facilitate transfer in a printable manner, the RFC includes a generic
representation for binary data in ASCII printable characters called Radix-64 or
more commonly "ASCII-Armor", which is essentially a Base64 \cite{rfc4648}
encoding with an added 24-bit CRC checksum.

Due to their structure, OpenPGP keys are append-only in their semantics.  All
relevant data in an OpenPGP key is signed but not necessarily by the key itself,
it is up to each implementation to decide whether information provided by an
individual packet is valid.  The order of certificates, since unsigned, is also
never relevant.  New information like prolonged expiry of a key is introduced to
a key by adding a certificate with a newer timestamp under the same packet it is
related to, overriding the older one.  This makes two snapshots of the same key
easy to merge, since packets not present in one key can simply be added at the
same position in the other.  This also means that data can only be appended to
the structure, never deleted.  This property enables distribution of OpenPGP
keys in an entirely unauthenticated way via keyservers (see
\Fref{sec:keyservers}).

*** Algorithms
<<sec:openpgp-algos>>

Like most communication protocol standards, the OpenPGP standard abstracts over
algorithms, strictly defining the algorithms to use only in a few places and
leaving the choice up to the implementation or user otherwise.  Specifically the
asymmetric encryption algorithms used in keys, synchronous encryption algorithms
used for encryption, and hashing algorithms used for generating signatures can
all be parameterized per operation.  All supported algorithms are assigned
numbers in an IANA registry per type \cite{ianapgpparameters}.  A simple
/Multi-Precision Integer/ (MPI) data format is also included, which covers the
needs for algorithm-specific data storage for all cryptographic algorithms.

*** Trust Model Neutrality

It is an important design decision of RFC4880 to stick to a purely technical
description of packet formats, almost completely foregoing standardization or
even description of trust models or even workflows.  A /trust model/ in this
sense includes a precise definition of which packets, signatures and
certifications are trusted under specific circumstances, taking into account all
issuer, expiry, revocation, and possibly notation data in all relevant signature
packets.  No constraints are imposed on a compliant implementation in this
regard.  This makes the OpenPGP standard suitable in theory as the basis for a
large number of different scenarios.

The lack of precision does also lead to major differences among interpretations
by developers of different implementations, and a strong dependency on de facto
implementations (see \Fref{sec:problems-impl}).

\clearpage

*** Implementations

The relevant implementations for the OpenPGP standard are relatively few in
number.  In this section, we briefly describe the most widely used ones.

**** GNU Privacy Guard
<<sec:gnupg>>

\begin{wrapfigure}{r}{0.25\textwidth}
  \centering
  \includegraphics[width=0.24\textwidth]{images/logo-gnupg}
\end{wrapfigure}

The /GNU Privacy Guard/[fn:gnupg] (GnuPG or GPG) is a GPL-licensed
implementation, whose first stable version 1.0.0 was released in 1999.  It was
initially developed by Werner Koch, who continues to maintain the software to
this day, with the latest stable release of version 2.0.27 in February 2015.
The GnuPG distribution is at this point a comprehensive suite of cryptographic
tools, and besides OpenPGP includes support for X.509 and S/MIME, as well as
Smartcards.  The core tool is "gpg" itself, which provides a fully featured
command-line interface.  The packages also includes and a number of auxiliary
tools for specific tasks such as the "gpg-agent" for caching private key
material, and the "GNU Privacy Assistant" as a graphical user interface for key
management.

There are several libraries which wrap GnuPG to provide an API layer on top of
it, most significantly the GPGME library which is a part of the GnuPG suite
itself.  It is notable that many features of GnuPG are exposed exclusively via
the command-line interface, which means libraries need to run the "gpg"
executable as a subprocess for some features, and interface with it by parsing
the text output.

A plethora of tools exists which provide graphical front-ends to the core GnuPG
functionality or add its features to other applications, which are based on
GnuPG directly or via a wrapper library.  Notable examples include
Seahorse[fn:seahorse] and KGPG[fn:KGPG] as key management applications, and
extensions for almost all major e-mail clients, such as Enigmail[fn:enigmail] as
an extension for Thunderbird, GPGMail[fn:gpgmail] for the Mail.app Mac OS X
application, and gpg4o[fn:gpg4o] for Microsoft Outlook.

Since GnuPG has been around for a long time, it has an established status as the
principal OpenPGP implementation, and is arguably responsible for large parts of
the culture which emerged among users of OpenPGP and developers of related
tools.

Like all other fully featured implementations, GnuPG defines its own trust model
on top of the OpenPGP standard, incorporating many undocumented design decisions
to fill the gaps left by the standard.  This includes aspects like validity of
subkeys and identities given a context of binding and revocation signatures,
order of priority in which preferences from different packets are used, and many
more.  Due to the reach of GnuPG, many user expectations which are attributed to
OpenPGP compatibility are in fact design decisions made by GnuPG (see
\Fref{sec:problems-impl}).

**** BouncyCastle
<<sec:impl-bc>>

The MIT-licensed /BouncyCastle/[fn:bouncycastle] library for Java and C# is a
library of assorted cryptographic primitives.  The library was first released in
May 2000 and is now maintained by the Legion of the Bouncy Castle Inc., an
Australian based non-profit association.

It provides its own "light-weight" API, but is also compatible with the Java
Cryptography Extensions (JCE) \cite{jcespec} and includes, among other things,
an implementation of OpenPGP.  This implementation adheres very strictly to the
standard, and is complete in the sense that it meets all criteria of a compliant
implementation.  Like the standard itself, it contains no trust model and
instead limits itself to definition of a data model and interfaces for
operations on this model.

Implementations which use BouncyCastle for their OpenPGP operations include the
Android applications OpenKeychain[fn:openkeychain] and r2mail2[fn:r2mail2].

**** Symantec Desktop Email Encryption
<<sec:impl-pgp-desktop>>

The PGP implementation is the successor the original, commercial product created
by Phil Zimmermann, which was released in 1991
\cite{Zimmermann:1995:OPU:202735}.  The "PGP" trademark was sold multiple times
and was most recently acquired in 2010 by Symantec.  The original PGP software
is no longer sold as a separate product, but has been integrated into the
/Symantec Desktop Email Encryption/[fn:symantecpgp], which includes support for
a larger variety of security tools and protocols, including OpenPGP and S/MIME.
As a proprietary implementation, Symantec Desktop Email Encryption targets
primarily business customers.  Although the application is not open source, its
source code is available for peer review \cite{symantec-pgp-code}.

** Authentication in OpenPGP
<<sec:pgp-authentication>>

The OpenPGP Message Format is designed to facilitate end-to-end encryption and
signing of messages using public-key cryptography, which means public keys used
in OpenPGP are usually assumed to be exclusively controlled by a single person
(or entity).  To avoid MitM attacks, it is necessary for the sender to have some
sort of verification that the public-key they use is (only) controlled by the
recipient.  In this section, we will look at trust links provided by or
implementable on top of the OpenPGP standard.

*** Keyservers
<<keyservers>>

Transferable OpenPGP keys are an append-only data structure which is easy to
merge (see \Fref{sec:transferable-keys}).  Since all relevant data is also
signed, no authorization is strictly required to add new packets to any key
during distribution.  Instead, each client is responsible to decide on the
validity of each individual packet during import, based on their own trust model
or policies.  This structure allows for a network of servers known as
/keyservers/ to act as a platform for distribution.

There is a protocol for querying keyservers called the OpenPGP HTTP Keyserver
Protocol (HKP) \cite{shaw2003openpgp}, which is based on HTTP and attempts to
unify the plain-text format output by keyservers at the time of its writing.
This standards document has been in draft status since March 2003 and has
formally expired in September 2003, but is still used as a basis for
HKP-compliant implementations.

There are two approaches to keyservers which are implemented and deployed on a
larger scale at this point, which are the /SKS Keyservers/ and the /PGP Global
Directory/.  They differ in a number of fundamental design decisions, and each
have their own advantages and disadvantages.

**** SKS Keyservers
<<sec:keyservers>>

The SKS Keyserver is an implementation written in O'Caml which emerged in 2008.
Its core feature is a gossip protocol which allows efficient synchronization
among a pool of servers \cite{minskysks}.  A decentralized, synchronized pool of
SKS Keyserver instances[fn:sks-keyservers] is likely the most widely used type
of keyserver, although only limited usage statistics are available due to the
decentralized nature of OpenPGP.

This implementation is primarily designed for the distribution of key data for
keys which are already known to clients, e.g., by fingerprint.  There is no
restriction of uploaded keys, and a deletion of key data is not supported, which
makes data obtained from these keyservers very unreliable.  Since OpenPGP keys
are meant to be verified and authenticated by each client themself, this is a
design decision, strictly limiting the scope of keyservers to distribution of
keys.  This decision is very much in keeping with the idea of the Web of Trust
(see \Fref{sec:wot}).

Although not mandated by the HKP standard for key retrieval, the SKS
implementation has support for search by User ID string.  This makes the
keyserver pool useful in theory for key discovery.  The usefulness of keys
obtained in this manner is somewhat limited though by the general concept of
keyservers which allows any user to add an unlimited number of User IDs to the
database with no verification.  If a search by name or e-mail address yields
only a single matching key, this result can arguably be assumed to be genuine in
a way similar to the TOFU model (see \Fref{sec:tofu}).  This approach is however
vulnerable to denial of service simply by uploading a second key with the same
User IDs: If more than one key exists, there is no way to judge which one is
genuine from the data alone, since all of it with the notable exception of the
fingerprint can be trivially forged.  This is particularly dangerous for cases
where a user's old key has been compromised in a way that the user was unable to
issue a revocation after the fact.  In general, the TOFU approach does not meet
the level of security usually aspired by users of OpenPGP.

**** PGP Global Directory

The PGP Global Directory[fn:pgp-global-dir] is a commercially operated keyserver
implementation by Symantec[fn:symantec].  It does not synchronize with other
keyservers, and does not implement the HKP protocol for key retrieval.
According to its brochure \cite{pgp_global_directory}, it also conforms with RFC
2440 \cite{rfc2440} only which has been obsoleted by RFC 4880 in 2007.  There
are no public statistics on the number of keys it stores or queries served per
day, so there is no data on the activity of this server.  This keyserver is used
as the primary keyserver in the commercial Symantec Encryption Desktop suite of
tools (see \Fref{sec:impl-pgp-desktop}).

This implementation is notable for its approach focused on adding a degree of
reliability to the keys it stores for retrieval, which is quite contrary to that
of the SKS Keyserver software.  Upon upload of a new key, a confirmation e-mail
is sent to the address of the key.  If the address is confirmed, the keyserver
issues a certificate for the key from its own public key, and makes it available
for retrieval.  Every six months after that, another e-mail is sent for each
key, which must be reconfirmed lest the key is deleted from the server.

The server stores only a single key for each e-mail address.  It also allows
users to remove their own keys from the index, again requiring confirmation by
e-mail.  Keys which are invalidated for any reason, including revoked and
expired keys, are automatically deleted from the server.  It explicitly
addresses spam concerns by allowing retrieval by exact match of e-mail addresses
and returning a single key on success only.

The nature of the PGP Global Directory keyserver arguably contradicts the
decentralized nature of OpenPGP.  Trusting in the certificates issued by the
keyserver yields easy retrieval of keys with a certain degree of verification
that the key is controlled by its advertised User IDs, but it centralizes trust
which defeats the personal authentication aspects of OpenPGP.  Not trusting in
certificates of the server on the other hand voids the advantage gained from
additional effort for key maintenance.

*** Authentication by Fingerprint

The fingerprint of an OpenPGP key is its canonical unique identifier, and the
most unambiguous one available which retains some accessibility to humans.  As
the most basic method of authentication during a personal meeting, the exchange
of public keys usually entails an exchange and manual check of fingerprints,
e.g., by reading the fingerprint to the other person.

A widely established method of verifying the identity of a person is checking
their go\-vern\-ment-is\-sued ID documents, but the actual security of this is
debatable since fakes are not easily spotted.  We forego here the rather
philosophical question of what exactly it is that defines a person, and instead
assume that a person can somehow convey their true identity in a personal
meeting.

#+BEGIN_figure
    \centering
    \begin{subfigure}[b]{0.49\textwidth}
        \centering
        \includegraphics[width=0.8\textwidth]{images/auth-fingerprints}
        \caption{Fingerprint exchange between users} \label{fig:auth-fp}
    \end{subfigure}
    \begin{subfigure}[b]{0.49\textwidth}
        \centering
        \includegraphics[width=0.8\textwidth]{images/trust-key-certify}
        \caption{Certification directly on a key} \label{fig:trust-key-certify}
    \end{subfigure}
    \caption{OpenPGP Authentication}
#+END_figure

\Fref{fig:auth-fp} depicts a fingerprint exchange between two users.  The
exchanged information identifies their keys, and the underlying statement made
in this exchange by each participant is that they believe that the key they
refer to is exclusively theirs, and also that they trust in all trust links made
by this key.  In other words, they authenticate the strong trust link to their
key for the other person.  If the other participant chooses to believe this
statement (that is, accept the other person as a trust anchor for this
information), they can then use this key for authenticated communication with
the other person.

The trust established between users by a fingerprint exchange must be documented
to be useful after initial authentication.  This means the user must document a
weak trust link from their key to the key of the other user, i.e., issue a
certificate for it.  Although the OpenPGP standard technically supports
certifications directly over a key (illustrated in
\Fref{fig:trust-key-certify}), this is not widely used in practice, which means
the trust link authenticated by a fingerprint exchange is not itself expressed
as a certification.  Instead, the type of certifications issued and recognized
by all notable implementations are made over identity packets in addition to the
public key.  The implications of this will be discussed in the following
section.

*** Certification of Identities

The OpenPGP standard has a concept of identities, more specifically User IDs and
Image Attributes.  A User ID is technically just a UTF-8 string and intended to
contain a name and address (see \Fref{sec:id-packets}).  Ignoring the
conventional contents, their general use is to associate keys with different
sorts of string data.

By established practice and influence of the GnuPG implementation,
certifications over identity packets are the widely supported way to certify
another person's key, certificates directly over the primary key are used very
rarely.  This leaves the user with the additional trust decision at the time of
authentication about which identity packets to certify.

**** Names

It is of course possible to simply put one's name, rather than an address, in
one User ID of a key.  A certification over a User ID such as this would be an
actual representation of the trust link which is authenticated during an
exchange of fingerprints and identities, without making a statement about the
addresses they control.  Alas, only a small minority of keys include a User ID
of this kind which could be certified.

**** E-Mail Addresses

The overwhelming majority of identities in OpenPGP keys are e-mail addresses
including names.  As mentioned before those are the content of User ID packets
intended (though not required) by the standard.  The suggested format is the
commonly used =Forename Lastname <address@example.com>= format, formally
specified in RFC 2822 \cite{rfc2822} as the =<name-addr>= ABNF rule.

#+BEGIN_figure
    \centering
    \includegraphics[width=0.7\textwidth]{images/trust-uid-certify}
    \caption{User ID certification upon fingerprint exchange} \label{fig:trust-uid-certify}
    The claim of ownership over the e-mail address is certified, but not authenticated
#+END_figure

After a fingerprint exchange, a user can create a certificate for the User ID of
the identified key.  Trusting a user to authenticate their own key by a simple,
unidirectional claim can be considered safe, because there is nothing to gain
from a false claim of control over a keyring.  This is different for
identification of an e-mail address, where a false claim of control allows the
user to sign messages in the name of an address they do not actually control.
The trust link which is certified in this case is not actually the one which is
authenticated by the user (cf. \Fref{fig:trust-uid-certify}).  This makes
certification of User IDs based on the claim of control by a person alone
problematic, it would be desirable to simultaneously authenticate the user's
claim of control over the address, i.e., the trust link from their key to their
identity.

The design of e-mail itself is fundamentally unsuitable to provide any means of
authentication.  Given an e-mail address, there is not only no way to verify its
owner, but it is not even possible to non-interactively find out if it is a
known address at the destination server without actually sending a message to
it.  With the privacy of users in mind, the SMTP standard used for e-mail
delivery includes no direct mechanism to obtain information about a recipient,
and due to the decentralized, asynchronous and fault-tolerant design of the SMTP
protocol there is also no (scalable) way to gather the information from
circumstances.  The only way to learn anything about a user from their e-mail
address directly (i.e., without resorting to related protocols) is from a
reaction received by sending a message to it, which of course requires
cooperation from the recipient.

Methods to authenticate e-mail addresses exist (see next section), but those
necessarily involve sending a message to the address (see above).  This leaves
no easy way to decide on the spot whether an address is genuine at the same time
the key is authenticated.  Because the attack scenario outlined above is not a
critical one, many users opt to trust the snapshot of User IDs in the
authenticated key and simply certify all User IDs.  There is however no
consensus on this matter.

**** CA Fire and Forget

One mechanism to authenticate e-mail addresses themselves is what is known as
the /CA Fire and Forget/ or /caff/ script, which is used to verify a given key's
control over an e-mail address.  To do this, the user issues a certificate for a
single User ID of the key, encrypts this certificate to the same key, and then
sends it to the e-mail address.  The recipient is then expected to publish the
certificate (e.g., by uploading it to the keyservers), proving that they have
control over both the key and e-mail address by receiving the message and
decrypting the attachment.  This method of verification verifies the trust link
solely between the address and the key, i.e., it proves to the issuer of the
certificate that both are controlled by the same entity, but includes no
statement about who that entity is.  When used in conjunction with some other
method of authentication between the key and the user, like an exchange of
fingerprints at a personal meeting, this provides a fully authenticated trust
path between the users via the certified e-mail addresses.

** The OpenPGP Web of Trust
<<sec:wot>>

In this section, we describe the mechanisms of the so-called Web of Trust (WoT),
point to some evaluations and look at conceptual and practical problems.

*** Mechanisms of the Web of Trust

#+BEGIN_figure
    \centering
    \includegraphics[width=0.7\textwidth]{images/weboftrust}
    \caption{Web of Trust}
    \label{fig:wot1}
#+END_figure

Signature Packets issued by an OpenPGP key can be published by uploading them to
a keyserver.  Quite importantly, the structure of keys and the way keyservers
work (\Fref{sec:keyservers}) makes it possible that certificates are not
uploaded to be part of the issuing key, but rather attached to the key they are
issued for.  This means keys which are available for download from the
keyservers already include all certificates made towards it.

This mechanism makes certificates readily available as a basis for trust
decisions, and forms the basis of the Web of Trust.  The WoT is essentially a
user-centric and self-organized form of PKI (see \Fref{sec:trust-pki}).  Every
user in the WoT acts as a CA, issuing certificates to users (or more precisely,
User IDs of their keys) who have authenticated to them according to their
personal certification policy.

To make use of this data, a user keeps a local registry called the /ownertrust
database/, where the user maintains a list of keys whose certification policy
they trust.  A key can be trusted fully or marginally, where a configurable
number of certificates from either type of trusted keys are necessary for an
identity to be considered genuine.  Default values in GnuPG for these settings
are one for fully trusted keys, and three for marginally trusted ones.

The WoT is not formally specified but exists as a de facto standard only.  Its
main influence is the GnuPG implementation, which established the concept of the
ownertrust database \cite{gnumanual} and is used as a backend in most
OpenPGP-compatible communication applications (see \Fref{sec:gnupg}), although
social conventions and a plethora of tutorials on the web also play a role.  In
particular, policies for certification vary among users and communities.  A
common baseline for all policies is that personal contact between users is
required to certify a user's key, exchange and inspection of personal identity
documents is also common practice.

*** Keysigning Parties

To rapidly establish a fully meshed network of mutual certifications between a
limited number of users, the concept of /keysigning parties/ has emerged, often
organized in the context of security-related conferences.  As usual (see
\Fref{sec:pgp-authentication}), this process of certification requires that each
two participants have to manually verify each other's fingerprints and identity
documents, then certify exactly the identities requested \cite{keypartyman}.

A number of procedures exist to reduce the time required, which usually involve
adding one's fingerprint to a list which is published to all participants before
the event, reducing the actions required at the event itself to verification of
this list and identity documents.  Despite these measures, keysigning parties
take a long time, dissuading all but the most security conscious users.

*** Adoption

The Web of Trust has been analyzed in several ways, including statistics on mean
shortest distances, and signatures between keys in certain domain names
\cite{leafoftrust}.  Significant results from these inspections are the
prominence of interconnected keys which have identities at the =.debian.org=
domain, pointing to the strong use of OpenPGP among the Debian[fn:debian]
developer community, and the footprint of an initiative by the German magazine
Heise[fn:heise], which has been certifying OpenPGP keys at conventions as part
of an ongoing campaign since 2011 \cite{heisekrypto}.

Despite this, the WoT certification model has so far failed to gain widespread
adoption.  One measure in terms of users who are actually connected in the WoT
by mutual authentication is the number of keys in the /strong set/, i.e., the
largest set of keys which are strongly interconnected by certificates.  A key
which is not in this set has no mutual certification with any key which is part
of it, and can be assumed to neither bear significance to the WoT nor draw any
advantage from it \cite{ulrich2011investigating}.  At the time of this writing,
the number of keys available on public keyservers is roughly 3.7 million, out of
which only roughly 55 thousand are in the strong set \cite{wotstrongset}.  This
number is very small in the context of e-mail users worldwide --- for context,
GMail alone reported to have "more than 350 million people" in 2012
\cite{googleceo}.

This is also attested by the observation that none of the widely used e-mail
user agents (including Mozilla Thunderbird, Microsoft Outlook, Apple Mail, and
GMail) come with built-in support for OpenPGP, moving this functionality into
extensions instead.

*** Problems

As established in the previous section, the WoT has so far failed to gain
widespread adoption, compared to the size of the established user base of
e-mail.  In this section, we point out a number of problems with both the
OpenPGP standard, and implementations of WoT mechanisms.

**** OpenPGP Implementation Complexity
<<sec:problems-impl>>

To deal with the intricate mechanisms required for the WoT, tools need to have
specialized key management facilities.  It is a common and reasonable
expectation of users that all OpenPGP-compliant implementations are
interoperable with one another, even though OpenPGP compliance leaves much
behavior undefined including parts very relevant to security.  Instead,
developers are mostly on their own to figure out a trust model to implement on
top of OpenPGP which is secure, understandable to the user, and compatible with
other implementations.

A basic example of a design decision that is not specified but needs to be made
by the implementation: It makes sense to use only subkeys which are bound to the
primary key with a valid subkey binding certificate.  While the standard
includes the packets to express this concept, verification of a subkey in this
manner is not a stated requirement.

Most implementations try to follow Postel's law, which states to be
"conservative in what you do, liberal in what you accept" \cite{rfc761}.  To
maintain interoperability with other implementations, one can define four
general approaches to every design decision:

- Support the use case in a way that leads to predictable behavior :: Even if
     the use case is only introduced by another implementation.  For example, an
     implementation might respect expiration dates on certificates, even if it
     offers no support to set them in certificates it issues.  While this is a
     viable solution in all cases for the user, since there are a large number
     of such decisions this option introduces equally large amounts of code
     complexity which need to be maintained, for a use case that is not actually
     endorsed by the particular implementation.

- Ignore the use case in the implementation, documenting the behavior :: This is
     a dangerous approach for general purpose implementations, since it
     introduces cases where the behavior differs from what a the user might
     expect from experience with other implementations.  Sticking with the
     example of expiration dates, a certification might be considered valid at a
     point when it is, by stated intent of the issuer, expired.

- Reject keys which make use of unsupported features ::  This is a safe approach
     (in comparison to the previous one), but also restricts functionality.  An
     implementation which rejects certifications which contain an expiration
     date avoids treating these certifications as valid when they have actually
     expired, but also limits interoperability to keys which do not depend on
     such certifications.

- Implement the use case differently :: There is not always consensus among
     implementing developers on what the expected behavior for particular
     constellations should be.  If no agreement can be reached, or no dialogue
     is attempted, an implementation can of course make their own decision,
     running the risk of losing interoperability and breaking with user
     expectations.

Each of these decisions has their own drawbacks, which makes implementing an
OpenPGP compatible application a demanding task.  While this is not directly a
problem of the WoT, it can be assumed to be detrimental to the resulting user
experience.

**** User Complexity

The WoT is very demanding on the user, since it requires them to make a large
number of trust decisions, each of them with implications on security.

A number of arguments can be made about social factors hampering the growth of
the WoT: Certificates need to be issued and maintained with a very high amount
of diligence.  Every user is potentially subject to trust in the ownership
databases of other users, a fact usually unknown to the user.  This puts an
implicit burden of responsibility on the correctness of every single issued
certificate, to ensure not only the confidentiality properties of the issuer's
own communications, but possibly that of other users as well, and even small
oversights can potentially jeopardize security properties for a large amount of
users.  Although this can in theory be compensated by redundancy of trust paths
in the WoT, these factors combined have led to a very strict set of accepted
best practices including a manual check of key fingerprints and inspection of
identification documents.

Few users have the expert knowledge to understand the intricate implications of
certificates they issue, which participants into extremely conservative behavior
in their issuance of certificates and trust.  This has also led to a culture
where users are ostracized if they fail to conform to the required best
practices in the perception of others, which is evident from public discussions
on the subject \cite{debconfrage}, and can be speculated to stop many potential
users from taking part in the WoT for fear of making a mistake or uninformed
decision.

# pull up widow line
\enlargethispage{\baselineskip}

Several studies have been conducted on the usability of PGP.  In the early and
well-known paper "Why Johnny Can't Encrypt" \cite{johnny}, Whitten and Tygar
demonstrated in a study on PGP 5.0 that only few users were able to correctly
encrypt e-mails with it.  Only 4 out of 12 participants were able to
successfully sign and encrypt an e-mail message in a 90 minutes experiment, 3
others sent the unencrypted plaintext by accident.  They concluded that
"designing security software that is usable enough is a specialized problem, and
user interface strategies that are appropriate for other types of software will
not be sufficient to solve it \cite{johnny}."

Garfinkel and Miller suspected the usability problem of software based on
OpenPGP to lie with the underlying approach to key management \cite{johnny2},
suggesting Key Continuity Management (which is similar to TOFU, see
\Fref{sec:tofu}) as an altogether different approach.  Kohlas et
al. reinterpreted the WoT as a probabilistic model, assigning percentage values
to trust links to make them more meaningful to users \cite{kohlas2008trust}.
Tong et al. suggested use of keys, locks, seals and imprints as a different set
of metaphors \cite{tongking}.  Although none of these approaches gained much
traction, they all point to the certification scheme and the WoT as a large
factor in usability problems of OpenPGP.

**** Privacy

The requirement to publish all issued certifications for the WoT to work as
intended raises issues about the users' privacy.  The keys of all users
including certifications in a non-obscured format are available by design on
keyservers, which means dumps of all keys can be downloaded.  This makes it easy
to gather statistics on the keys participating in the WoT like the
interconnectedness of keys, trust paths between users or communities, and use of
particular types of packets.  An active user of the WoT is effectively required
to publish and maintain a graph of their social connections, including
timestamps of when they met and verified identities with each of their certified
keys.

Surprisingly, this has not come up as a serious issue on the current scale of
deployment, considering that OpenPGP targets an audience which is fairly
concerned with privacy.

* Linked Identities
<<chap:lids>>

In the previous chapter, we explored the trust paths available in OpenPGP, how
they connect to one another, and what their particular advantages and
disadvantages are.  In this chapter, we introduce /Linked Identities/ as an
alternative and complementary approach, considerably extending the space of
possible trust nodes.

** Rationale

Almost every active user on the internet has some small pieces of the web that
they have control over which is exclusive to them for most intents and purposes,
and which they in this sense rightfully claim as their own.  These "pieces of
the web" range from ubiquitous resources which are used by almost everyone
including accounts on communication, commercial, or social platforms to more
advanced use cases of tech savvy users such as personal websites, domain names,
or even OpenPGP keys.  For many of those cases, there is a measure of
established trust in the resource, or rather the exclusiveness of control by the
particular user.  This exact property is what makes them useful as a stand-in
means of authentication.

For a more concrete scenario, once a user has demonstrated control over a
resource, one of two things must logically be true: Either the user is who they
claim to be, or the previous assumption of exclusive control is false.  In the
former case, the user has successfully authenticated themself as the owner of
the resource.  The latter case can have a variety of reasons, although the most
likely one is that the account has been overtaken by a malicious third party.
This failure case is usually very disadvantageous to the user who is being
impersonated since it means they lost ownership of the resource. The stake the
user holds in a particular resource thus extends to the authentication performed
with it.

The simple idea of Linked Identities is to enable OpenPGP keys to connect
themselves with resources of just this kind, tying the authentication of their
owner to the credibility of the resource.  In short, a Linked Identity is a
cryptographically verifiable, mutual relation between an OpenPGP key and an
arbitrary resource on the web, meant to support users in the decision of whether
a key is genuine or not.

** Requirements Identification
<<sec:requirements>>

Linked Identities aim to extend the range of implementable trust models in
OpenPGP by introducing the aforementioned resources as a new type of supported
trust nodes, which we will call Linked Resources.  Going for a top-down approach
here, we start the process by figuring out the precise requirements to implement
Linked Identities on top of OpenPGP.

# push down orphan line
\clearpage

#+BEGIN_figure
    \centering
    \begin{subfigure}[b]{0.48\textwidth}
        \centering
        \includegraphics[width=0.75\textwidth]{images/linked-id-claim}
        \caption{Claim}
        \label{fig:linked-id-claim}
    \end{subfigure}
    \begin{subfigure}[b]{0.48\textwidth}
        \centering
        \includegraphics[width=0.75\textwidth]{images/linked-id-proof}
        \caption{Proof}
        \label{fig:linked-id-proof}
    \end{subfigure}
    \caption{Linked Identities}
#+END_figure

For a fully capable Linked Identity, there must be two working parts: Firstly, a
documented and verifiable claim must be created that some Linked Resource
belongs to an OpenPGP ring.  Secondly, this Linked Resource must provide
evidence which supports the claim.  This leads to three basic requirements for a
concrete Linked Identity model:

- Trust Node Identification :: A resource which is to be used as a Linked
     Resource will need some way to be uniquely identified.  This is a simple
     requirement for all candidate resources where a URI scheme for this purpose
     exists.
     <<sec:requirements-trustnode>>

- Trust Link to Linked Resource :: As the most basic requirement, a way must be
     provided for an OpenPGP key to make a documented claim of control over a
     Linked Resource, i.e., express a trust link towards it
     (cf. \Fref{fig:linked-id-claim}).  Documented claims are easily available
     since signing data is an integral capability of OpenPGP keys, which reduces
     this requirement to creating a well-defined data format for such claims,
     making use of the identifiers from the requirement above.

     The claim does not in and of itself depend on either the key or the
     resource.  This means there are no strict requirements in terms of storage
     and distribution, the particular mechanism chosen for this aspect primarily
     affects discoverability.  Depending on this choice, it might be desirable
     for a claim to be itself uniquely identifiable, this is not a general
     requirement though.

- Trust Link to OpenPGP key :: A Linked Resource must be able to provide
     evidence in some way which supports the claim made by the key, i.e.,
     express a trust link towards it (cf. \Fref{fig:linked-id-proof}).  The
     precise mechanism for publication is not fixed, so long as it is
     retrievable by its target audience.

     For types of Linked Resources where the publishing itself implies an
     authentication, it suffices to simply have an unambiguous affirmation of
     the existence of the claim.  The amount of data that needs to be published
     to form a valid trust link in this case must be enough to uniquely identify
     the OpenPGP key, which implies the length of an OpenPGP fingerprint (20
     bytes) as a lower bound.

An important aspect of trust links is their verifiability.  This is already
provided for the trust link from an OpenPGP key to a Linked Resource, since the
key can simply sign the data.  The other direction is more complicated; since
authentication of the user is implied by the process of publishing the Linked
Resource itself, the only required mechanism is for fetching the published
resource in a reliable way.  While this is a simple task for individual
resources, it is impossible to do in a generic fashion.  This dictates a need
for an implementation to have specialized support for every Linked Resource type
they support individually, making this aspect one of the largest challenges for
an implementation of Linked Identities.

** Exemplary Types of Linked Identities
<<sec:example-lids>>

Following the observations from the previous section, the actual technical
requirements of a resource to be suitable for use as a Linked Resource in any
Linked Identity model are that they must be uniquely identifiable, suitable to
store at least 20 bytes of data, and can be retrieved by their target audience.
These requirements fit with any service or protocol which can be used as an
authenticated key-value store.  It is an easily met criteria, allowing for a
large amount of possible Linked Resource types.  We will present in this section
a selection of resources suitable as a Linked Resource, and discuss their
particular qualities.

*** DNS Domain Names
<<sec:lid-example-dns>>

The /Domain Name System/ (DNS) is by its very definition an authenticated
key-value store, it features a decentralized structure to associate data with
names in a hierarchical structure.  The core of DNS is most recently specified
in RFC 1034 \cite{rfc1034} and RFC 1035 \cite{rfc1035}, and is extended by more
than fifty additional RFCs which introduce new extensions or provide more
specifics on particular implementation aspects.

DNS is a complex system with many stakeholders, administrative levels, and
extensions.  In the scope of this document, we will limit focus on the parts
which are relevant for understanding the use of domain names as a Linked
Resource.

#+BEGIN_figure
    \centering
    \includegraphics[width=0.75\textwidth]{images/dns-zones}
    \caption{Zone Delegation in DNS}
    \label{fig:dns-zones}
#+END_figure

As a rough overview, the DNS maps the domain name space to data in a tree-like
structure, which is subdivided into zones.  A DNS domain name is read from right
to left, each part of the domain delimited by a dot.  At the far right of any
domain name is a top-level domain (TLD) such as =com=, =org= or =net=, followed
by a domain, followed by any number of subdomains.  For each particular domain,
there is a nameserver which is authoritative for the data of the domain and all
its subdomains, called a zone.  The hierarchical structure comes from the
ability of a /nameserver/ which is authoritative for a zone to delegate this
authority to a different nameserver for specific domains in its zone (see
\Fref{fig:dns-zones}).  The topmost such zone is the /root zone/, which
delegates authority to the TLD zones, which each delegate the authority further
down.

Within its zone of authority, a nameserver can associate domain names with
records.  Some of these records are used internally by DNS servers, e.g., for
the delegation structure, others can be used to associate a domain name with
data used by other services, the available types of records are defined in
various RFCs.  The two most widely used purposes of DNS are the resolution of
domain names to IP addresses (the /A record/ for IPv4 addresses), and
declaration of the server responsible for accepting e-mail addressed to a domain
(the /MX record/).  DNS is an integral part of what shapes "The Web", and a DNS
resolver is deployed in almost every network stack.

What is available for purchase to consumers in the DNS system is authority over
zones, usually at domain level.  The names are available on a first come first
served basis from registrars themselves, although an entire market has emerged
where the rights to popular domain names are registered and offered at higher
prices by resellers.  Still, many domain names are privately owned and commonly
used for personal e-mail addresses or websites.

The /TXT record/ is a general purpose type of record, which can contain
arbitrary string data.  One domain may have several such records, each with a
maximum length of 255 bytes, and by convention formatted as a key-value pair
delimited with a "=" character.  Using this record to point to an OpenPGP key,
combined with the proof of control over a domain name, makes DNS well suitable
as a Linked Resource.

Administration of a domain name is perceived as a difficult endeavor.  Platforms
for small personal websites usually handle configuration of domain names
automatically, even if the user is the official registrant and administrative
contact of a domain, the actual administrative aspect of domain ownership is
often hidden to the user.  This makes the range of potential users fairly
limited even among domain name owners.

The authentication properties of DNS are fairly established, due to their solid
history domain names are perceived to be difficult to hijack.  Various services
already trust that a user owns a domain for a variety of purposes if they prove
control over a record.  A prominent example are CAs which accept verification
via e-mail \cite{certvulnnote}, which in turn depends on the MX record of a
domain.  Despite this, domain name resolution is fairly easy to hijack locally,
and practical security based on cryptographic properties has only been emerging
in recent years in the form of the DNSSEC extensions.  See \Fref{sec:attack-dns}
for a more detailed discussion on relevant aspects of DNS security.

*** Websites (TLS)
<<sec:lid-example-website>>

# pull up widow line
\enlargethispage{\baselineskip}

Personal websites are a common occurrence including personal blogs, professional
career portraits, family websites, or individually curated information on a
topic of interest.  For the group of users who both own a personal website and
use OpenPGP for secure communication, it makes sense to have a reference to
their key or even the public key itself on their website under contact
information.  This is already done in practice by many individuals, and
occasionally even companies who markedly value the privacy of their customers.

A website with a reference to an OpenPGP key is essentially already a Linked
Resource, missing only the trust link from the OpenPGP key to the website to be
a full Linked Identity.  The ease of use and understandable nature of websites
makes this type of Linked Resource very suitable for intermediate users,
especially if they already own a personal website.

The cryptographic properties of a Website depend on its use of TLS, which means
there is no security at all if TLS is not used to access the website.  Otherwise
the security properties are equivalent to those of TLS, which in turn depends on
the X.509 PKI (see \Fref{sec:attack-websites}).

*** Social Media Accounts

Accounts on social media are perhaps the most relatable and universally useful
type of Linked Resource available.  For the everyday online interaction of most
users, the profiles on social media platforms such as Reddit, StackExchange,
Twitter, and GitHub have become the representation of a person's online persona.

There are generally two ways to publish a trust link to an OpenPGP key on a
social media account:

- Add it to the account's public profile page.  Many social media platforms
  provide a way for the user to add a description to their profile.  This is a
  good way both to authenticate and advertise an OpenPGP key, it is however in
  this way also more visible than some users might prefer, especially on sites
  where the total allowed length of profile text is limited.

- Link to the OpenPGP key in a publicly accessible message which is associated
  with the account.  This is an available method if the platform provides a way
  to publish uniquely identifiable messages of at least 20 bytes.  This method
  has less exposure than including the information in the profile page directly,
  which may be desirable for users who prefer to keep their cryptographic
  assertions subtle.

In modern use of the internet, cases where communicating parties only know each
other by way of social media profiles rather than in person are becoming
increasingly more common.  Under these circumstances, social media profiles can
actually provide a more precise representation of the identity of the
communication partners than government-issued ID documents.

**** GitHub
<<sec:lid-example-github>>

\begin{wrapfigure}{r}{0.1\textwidth}
  \centering
  \includegraphics[width=0.08\textwidth]{images/logo-github}
\end{wrapfigure}
GitHub[fn:github] is a code sharing platform and social network, whose tagline
is "Build software better, together."  It provides free hosting of Git
repositories, and includes communication features such as issue trackers and a
wiki per repository.  In recent years, GitHub has become a central point of
development and distribution for many open source software projects.

Accounts on GitHub are used to post messages in issue trackers, and also keep
track of the user's contributions to repositories in the form of Git commits.
This makes GitHub Linked Resources useful to securely contact developers who the
user already knows on this platform or recognizes by their contributions and
posted messages.

It must be noted that creation dates and authorship data in Git commits can be
trivially faked, which also affects the commit history of an account on GitHub.
It is also possible to add arbitrary e-mail addresses to a GitHub account which
are then used to associate commits to that account (verification is only
required for password reset and notification functionality
\cite{githubcommitslink}).  For these reasons, the histories and association of
Git commits with user accounts on GitHub should not be considered reliable
information.

\begin{example}
    \centering
    \vspace{0.2cm}
    \texttt{https://gist.github.com/Username/0123456789abcdef0123}
    \caption{GitHub Gist URI}
    \label{ex:uri-github}
\end{example}

Although GitHub does not have an actual notion of public messages outside of
comments on issues, it has a service called "gist" which is intended to allow
users to publish pieces of code or data.  A Gist is uniquely identifiable by a
URI (see \Fref{ex:uri-github}), authenticated by the user, and can hold (almost)
arbitrary amounts of text, fulfilling all criteria of a suitable Linked
Resource.

**** Reddit

\begin{wrapfigure}{o}{0.1\textwidth}
  \centering
  \includegraphics[width=0.08\textwidth]{images/logo-reddit}
\end{wrapfigure}
Reddit[fn:reddit], stylized as reddit, is a community-driven entertainment, news
and social networking website.  It is based around user-submitted content in the
form of links or images, which can be discussed and voted "up" or "down" by
other users to display their like or dislike.  The site is organized similar to
a bulletin board in several thousand "subreddits", 50 of which are featured on
the front page.  Users, who are referred to as "redditors", also earn "link
karma" or "comment karma" for posting popular links or comments, respectively.

Profiles on reddit feature no freely customizable data, which leaves the
possibility to post a topic which includes the reference to the key as a Linked
Resource.  The Keybase implementation (see \Fref{sec:keybase}) created a
subreddit[fn:keybase-subreddit] for this particular purpose.

**** StackExchange

\begin{wrapfigure}{i}{0.1\textwidth}
  \centering
  \includegraphics[width=0.08\textwidth]{images/logo-stackoverflow}
\end{wrapfigure}
StackExchange[fn:stackexchange] is a network of websites based on the question
and answer formula on assorted topics in a large variety of fields.  At the
point of this writing, it consists of 142 specialized websites covering a
specific topic each. The network sites are originally based on
StackOverflow[fn:stackoverflow], which specializes on programming questions.
All users, questions and answers are subject to a reputation award process based
on badges and a reputation score, which is designed to allow the sites to be
self-reliant in terms of moderation.

Users on StackExchange have a comprehensive profile page with a uniquely
identifying URI, which shows an overview of the user's most reputable answers,
badges and reputation earned on the site, and also a description text which can
be freely chosen, and can thus contain a Linked Resource Token.  The focus of
StackExchange profiles on reputation makes them quite suitable as a means of
authentication.

**** Twitter
<<sec:lid-example-twitter>>

\begin{wrapfigure}{l}{0.1\textwidth}
  \centering
  \includegraphics[width=0.08\textwidth]{images/logo-twitter}
\end{wrapfigure}
Twitter[fn:twitter] is an online platform which allows its users to publish and
view messages of 140 characters or less, known as /tweets/, which with its
upwards of 280 million active users has gained considerable reach.  Every user
has a "timeline", where all their own tweets and those of other users they
"follow" are accumulated.

Twitter accounts are very relatable, and it is fairly easy to distinguish
genuine accounts from fake ones by their number of followers, registration date,
and tweets which have been published since then.  On top of this, the entire
concept of Twitter is centered around "following" other users, so all users
already have a curated list of known accounts.

\begin{example}
    \centering
    \texttt{https://twitter.com/Username/status/012345678901234567}
    \caption{A Twitter Tweet URI}
    \label{ex:uri-twitter}
\end{example}

A tweet posted on a Twitter account is uniquely identifiable by a URI (see
\Fref{ex:uri-twitter}), authenticated by the user, and can hold 140 characters,
which makes it suitable as a Linked Resource.  As an alternative possible Linked
Resource, a Twitter profile contains a description of the user called "bio",
which is limited to 160 characters in length.

** The Keybase Implementation
<<sec:keybase>>

\begin{wrapfigure}{r}{0.20\textwidth}
  \centering
  \includegraphics[width=0.12\textwidth]{images/logo-keybase}
\end{wrapfigure}
One implementation of Linked Identities, which predates the formalization of the
concept made in this document, is Keybase[fn:keybase].  Launched in early 2014
in an invitation-only alpha stage, this website is intended as a platform for
the authentication of OpenPGP keys by publishing proofs of identity in a
publicly auditable manner.

A fundamental design decision of Keybase is that all its features are
centralized around the =keybase.io= server, which provides all of its data via a
freely accessibly API \cite{keybaseapi}.  Identification of registered Keybase
users also uses a centralized namespace.

Most features of Keybase are available on the website, but there is also a
command-line client available.  This client is described as a "reference
implementation", underlining that the data managed by the Keybase server is
publicly available, and other users are encouraged to write their own clients.
The Keybase client is written in node.js[fn:nodejs], and wraps GnuPG for all
OpenPGP operations.  At the time of this writing, no alternative fully featured
implementations exist for Keybase, although OpenKeychain added support for
experimental verification of Keybase proofs in a recent version.

*** Keybase Objects
<<sec:keybase-objects>>

The Keybase server is, generally speaking, a centralized mechanism for the
storage of JSON objects which contain a payload, a signature for this payload,
and some metadata.  Each object is uniquely identified by the hash of its signed
payload.  The payload is itself a JSON object, and must be one of a fixed set of
object types, which each have defined semantics as a statement made by the
signing key.  For clarity, we will refer to a data object of this type as
/Keybase object/.  There are four types of payload a user can store on Keybase:

 - Key ownership :: A Keybase object with this type of payload is the
      declaration that an OpenPGP belongs to the stated account on Keybase.
      When a user first creates an account, they must also create a key
      ownership object in the process.

 - Identity proofs :: An identity proof object states a trust link from the
      OpenPGP key to one of the Linked Resource types supported by Keybase.
      This is the type of Keybase object which represents the actual purpose of
      Keybase, i.e., linking OpenPGP keys to Linked Resources.  The structure of
      this payload type is examined more closely in \Fref{sec:keybase-id-proof}.

 - Revocations :: A revocation object contains a reference to exactly one
      previous Keybase object, which is then declared as revoked by this
      revocation object.

 - Tracking statements :: A tracking statement captures the state of another
      user.  It is used to remember the verification made of another account in
      a signed way. See \Fref{sec:keybase-tracking}.

In respect to the OpenPGP key, all storage, signing, and authentication happens
entirely out-of-band on the layer introduced by Keybase.

*** The User Signature Chain

Although Keybase uses a centralized server for all storage, the design goes to
great lengths to make sure operation is possible without actually requiring
users to trust the Keybase server.  To this end, two mechanisms are used: The
inductive append-only structure of Keybase objects, and a Merkle Tree (see next
section) over all Keybase objects.

Keybase objects are structurally designed to be stored in a totally ordered and
append-only database.  Each Keybase object contains an incremental sequence
number, and also includes as a part of its signed payload both the sequence
number and hash of the signed data from the previous Keybase object.

The first Keybase object created by a user is the key ownership object which
ties their OpenPGP key to the account on Keybase.  This is the only object which
does not include a reference to a previous Keybase object in its payload.  All
further Keybase objects by this user depend on the state of the previous object,
and inductively on all Keybase objects made by that user up to this first one.

The purpose of this mechanism is to allow clients to verify not only the current
state of a Keybase account, but also its history.  This is used to prevent the
Keybase server from manipulating profile data by selectively suppressing
specific Keybase objects.  It is particularly important to ensure the correct
distribution of revocation certificates, which could otherwise be withheld to
prolong the validity of a Keybase object after its statement has been
invalidated, e.g., in the case of a compromised Linked Resource.

**** Fork Consistency
<<sec:keybase-fork-consistency>>

To bootstrap a signature chain, trust in a user's OpenPGP key is assumed.  By
signing the first Keybase object, the key creates a trust link from itself to
the account on Keybase, and can from that point on authenticate itself by adding
identity proofs to the signature chain.  If a user wishes to replace the OpenPGP
key used with their account for another one, a new Keybase object with the same
bootstrapped trust properties is created, which invalidates all signatures made
by the old key.  Since this operation is usually performed when the previous key
has been compromised or lost, the corresponding Keybase object is only
self-signed by the new key, not by the previous one.

This leads to a severe issue: The server could change the key used for an
account for one of their own.  Even though this invalidates identity proofs made
before this operation, it allows publication of proofs and communication in this
Keybase user's name.  In the worst case, a malicious server can "fork" the views
of different users, overriding account data only for specific targets.

Keybase achieves fork consistency \cite{li2004secure} by a method based on the
idea of Certificate Transparency (CT) \cite{laurie2014certificate}.  In order to
allow clients to verify the presence of signatures on the server, a Merkle Tree
\cite{merkletree} of all Keybase objects is maintained and published by the
server.  Whenever a change happens in the data (i.e., a new Keybase object is
added), the identifying hash of the new object is added to the tree and then
published.  The root of every iteration of this tree is then signed by a public
key used for this purpose only.

An implementation can then test for consistency of server data by checking if
all Keybase objects are present in the Merkle Tree.

# As an additional measure, the roots of the Merkle Tree are stored "for all
# eternity"[fn:keybase-eternity] in the Bitcoin Blockchain. (TODO)

*** The Identity Proof Keybase Object
<<sec:keybase-id-proof>>

The primary selling point of Keybase is of course its support for Linked
Identities.  Upon registration, a user authenticates their OpenPGP key to
Keybase itself, and can subsequently create Linked Identities to other Linked
Resources by creating Keybase objects with the identity proof payload.

The identity proof payload contains the following data:

- =body.key= :: A full reference to the key, including the fingerprint of the
     signing OpenPGP key, and a reference to the their and username of the
     Keybase account.
- =body.service= :: A reference to the Linked Resource, the exact data depending
     on its particular type.
- =ctime= :: A creation timestamp for this Keybase object.
- =expire_in= :: An expiry time, containing the number of seconds since creation
     until this object expires. This is set to five years by default.
- =prev= :: The payload hash of the user's previous most recently signed Keybase
     object.
- =seqno= :: The sequence number of the Keybase object which includes this
     payload.

This payload is made available together with its signature as a Keybase object
on the Keybase server.  It is also published on the site of the Linked Resource,
either in full, or as a reference if size is constrained.

To verify the identity statements of an account, the client software simply
acquires all relevant Keybase objects, verifies their signatures, and makes sure
the referenced Linked Resource sites do in fact contain or at least reference
the identity proof payloads.  This process is called the "computer review" in
the Keybase documentation, and is done by the Keybase server to provide a status
overview on the website, but is also repeated locally by the Keybase client when
communication with a new Keybase username is initiated.  In addition to the
computer review, the user is asked to make sure all sites used as Linked
Resources are genuine, which is called the "human review".

*** Tracking Statements
<<sec:keybase-tracking>>

Another feature of Keybase is the ability to /track/ other users
\cite{keybasetracking}.  The basic idea of tracking another user is to create a
Keybase object which contains a snapshot of the current state of that user's
signature chain.  This is done after and includes the conclusions drawn from the
"human review" step (see above).  The tracking object is then published as a
part of the user's own signature chain.

Tracking is used for two purposes: Firstly, it allows the Keybase server to
store the result of the human review performed by a user in a way that is signed
by the user themself.  This is necessary to make it available for retrieval by
the same user, e.g., from a different client, without requiring trust in the
Keybase server.

The second purpose is strengthening trust in the Linked Identities of an account
by keeping a track record of when the identity proofs were verified by different
users.  The user is in this way provided with a timeline of when other users,
whose signatures they potentially trust themselves, reviewed the identity proofs
and signature chain.  This lends additional reassurance that the account and all
its identity proofs have remained untampered with since their creation.

# push new section to next page
\clearpage

** Linked Attributes

In this section, we propose an implementation concept for Linked Identities
which is similar to the one found in Keybase in terms of user experience, but
uses an entirely different underlying mechanism for creation, distribution and
certification of the data based on existing OpenPGP infrastructure.

*** User Attributes
<<sec:user-attributes-compat>>

User Attributes are a type of identity packet in OpenPGP (see
\Fref{sec:id-packets}).  Their use is very similar to User ID packets, and they
can be used in place of a User ID packet in almost all places (see RFC 4880
p. 48 \cite{rfc4880}).  User Attributes consist of a vector of subpackets which
each have a single byte type identifier, a length and a payload.  The only type
declared by the standard is ID =1=, which is defined to contain a single JFIF
image.  Although it is possible to have more than one subpacket in a User
Attribute, implementations commonly assume that each packet contains only a
single subpacket for the case of JFIF.  The range of ids 100 to 120 is reserved
for experimental use, there are no RFCs which extend RFC 4880 and define
additional type ids.

The User Attribute packet type is technically able to contain any sort of data.
In a standards-compliant implementation, it also shares all fundamental
properties of User ID packets including self-certification life cycle, foreign
certifications and distribution mechanisms even if the particular subpacket type
are not supported.  The User Attribute packet is thus suitable in theory to
carry the information required for a trust link to a Linked Resource, with
mechanisms for certification and distribution which follow naturally from the
OpenPGP specification.

User Attribute packets are an optional part of the standard.  To confirm the
applicability of User Attributes for this purpose with current implementations,
we first explore the compatibility and particular behavior of implementations in
respect to User Attributes with unknown type IDs.

**** GnuPG compatibility

\begin{example}
\scriptsize
\begin{verbatim}
pub   4096R/DEADFA11 2012-07-14
(...)
uid                  [unknown attribute of size 71]
sig!3        DEADFA11 2015-04-27  Vincent Breitmoser <v.breitmoser@tu-bs.de>
\end{verbatim}
\caption{Partial output of GnuPG for \texttt{gpg --check-sigs 0xdeadfa11}}
\label{ex:compat-gnupg}
\end{example}

# pull up widow line
\enlargethispage{\baselineskip}

The GnuPG implementation in its stable version 1.4.18 correctly recognizes User
Attributes with a single subpacket of type ID 2 and 101, both import and export
of an OpenPGP key with the packet work as expected (see \Fref{ex:compat-gnupg}).
The packet is treated as a User ID with opaque content and displayed as such.
The self-signature on the packet is correctly verified and respected, in
particular the User Attribute is discarded upon import if it is missing the
self-signature.  GnuPG also supports output of raw data and certification of
User Attributes.

These observations suggest that newly introduced User Attributes are not only
correctly distributed and lead to no interruption of established workflows in
GnuPG, but that the data from these packets can also be used by external tools
with no further modification of GnuPG.

**** SKS Keyserver compatibility
<<sec:sks-compat>>

\begin{example}
\scriptsize
\begin{verbatim}
pub  4096R/DEADFA11 2012-07-14
(...)
uat [contents omitted]
sig  sig3  DEADFA11 2015-04-27 __________ __________ [selfsig]
\end{verbatim}
\caption{Partial output of the verbose key index for the key 7BD18320DEADFA11}
\label{ex:compat-sks}
\end{example}

The SKS Keyservers pool (see \Fref{sec:keyservers}) accepts User Attribute
packets regardless of their content if they have a valid self-signature (see
\Fref{ex:compat-sks}).  With this, distribution of newly specified types of User
Attributes can be assumed to work seamlessly and without modification to the
existing keyserver infrastructure.

*** Standardization as Internet Drafts

As a part the this thesis, Linked Identities have been standardized in Internet
Draft format, according to the IETF guidelines \cite{rfc2026}.  The reason for
this is twofold:

Firstly, interoperability and ease of implementation is a key requirement for an
extension like this to gain any kind of traction.

Secondly, and this is the stricter criteria, the proposed extension to RFC 4880
requires assignment of a new User Attribute subpacket type.  User Attribute
subpacket types are an IANA registry specified in RFC 4880 Section 10.2.1, which
can only be updated by way of IETF Consensus.  The IETF Consensus process is
described in RFC 2423 \cite{rfc2423}, and requires a document to be approved for
RFC status by the IESG.

The standardization of Linked Identities is split into two parts, a very short
one specifying URI Attributes as a new type of User Attribute
(\Fref{sec:uri-attributes}), and a larger one which specifies the URI scheme to
be used in Linked Identity packets, thus the actual data format and semantics
(\Fref{sec:linked-id-uris}).  The formal classification of both documents is an
independent contribution as an Experimental Internet-Draft which is not on the
standards track.

The URI Attribute specification has been split off into its own draft, because
the specification it covers is of more general use than for Linked Identity
URIs.  This is also helpful to get the required IANA assignment for the URI
Attribute type, without pulling the entire Linked Identity specification into
the process.

At the time of this writing, both drafts have been submitted to the IETF and are
in the state of Proposed Standard \cite{draftvburiattribute}
\cite{draftvblinkedids}.  In the following sections, we reproduce the content of
these drafts, adding some information on the decisions and design process.

*** URI Attributes
<<sec:uri-attributes>>

As a core design decision, the trust links used for OpenPGP Linked Identities
are encoded entirely as URIs, with no further externally stored information.  We
also assume that all Linked Resources can be referenced using a URI (see
\Fref{sec:requirements-trustnode}), although the URIs used to reference a Linked
Resource are often used only indirectly (see \Fref{sec:linked-id-uris}).

Following this design decision, we first introduce the URI Attribute as a new
type of User Attribute.  The contents of this section reproduce the Internet
Draft "URI Attributes for OpenPGP" \cite{draftvburiattribute}, adding discussion
on design decisions where appropriate.  Refer to Appendix
\ref{appendix:uri-attributes} for the full draft.

**** URI User Attribute Subpacket

The URI subpacket is added as an additional User Attribute subpacket, expanding
Section 5.12, "User Attribute Packet (Tag 17)" of RFC 4880.  The type ID for
this packet is to be declared by IANA upon approval of the Internet Draft, it is
expected to be =2=, which is the next free ID number. For the implementation,
the packet ID 101 from the range of experimental ids is used to avoid later
problems with compatibility.

The body of this subpacket consists of a single URI string, with a fixed
encoding of UTF-8, just the same as User IDs.  A User Attribute with a single
subpacket with the URI type is called a URI Attribute.

Similar to RFC 4880, the scope of the Internet Draft is limited to a technical
description of the format, and does not include specifics of any kind on how URI
Attributes may be used by implementations.  An implementation may choose to
treat URI packets with unknown URI schemes as opaque content, or display their
contents in a generic way.

The overall purpose of this packet type is to provide a mechanism to allow an
OpenPGP key to associate itself with an identity encoded in a URI. The
particular semantics of URIs used in this context depend entirely and
exclusively on its scheme.  An important aspect is that compliant
implementations are discouraged (though not forbidden) from issuing certificates
of any kind for URI Attributes where they have no semantic knowledge of the
scheme of the URI.  This delegates, to a certain degree at least, the semantics
of a certification on this type of identity to the standardization of the scheme
used in the URI, in a way which is flexible enough to be extensible and yet
rigid enough to base authentication assumptions on.

**** Rationale
<<sec:uri-attribute-rationale>>

Generic URI Attributes were chosen over a specialized Linked Identity packet
type to keep standardization and implementation complexity to the minimum
possible.

The strictly minimum information required to encode a trust link to a Linked
Resource is a reference to the resource, and a signature over this data.  Since
User Attributes in OpenPGP keys are already required to be accompanied by a
certificate which binds them to the OpenPGP key's primary key, thus taking part
in the regular life cycle of OpenPGP identity packets, the requirement left is a
User Attribute which contains exactly a URI to the Linked Resource.

Representing trust links as plaintext data also makes it possible to handle this
information without use of specialized tooling during development, which
benefits developer dialogue.

Implementations require specialized support for each distinct type of Linked
Resource (see \Fref{sec:requirements}), which means encoding the trust links as
URIs makes it necessary to parse the type of Linked Resource from the URI.  An
alternative approach, and the one used by Keybase (see
\Fref{sec:keybase-id-proof}), would be introducing a registry of Linked Resource
types, where each type is assigned an identifier and has their own defined
specialized data and semantics.  This requires a larger amount of communication
among developers or even additional standardization for the defined semantics of
specific Linked Resource types to be a viable approach in a setting which is
less centralized than Keybase.  Since the type of resource can be parsed from
the URI itself for any given Linked Resource URI, leaving the resource type
implicit in its URI avoids a whole layer of management which would otherwise be
necessary to achieve implementation interoperability.

**** Relation to User ID Packets
<<sec:uri-attributes-uid>>

URI Attributes are technically equivalent to User IDs in that they hold a
single, UTF-8 encoded string.  Since User IDs are only suggested but not
required to contain a name or address, and we assume trust links to be fully
encoded in a URI, it would be a technically viable option to directly use User
ID packets for this purpose.

This is not desirable to retain conformity with user and implementation
expectations.  Many implementations (e.g., OpenKeychain, Enigmail) parse User
IDs to separately display name and e-mail address, using display of the raw data
as fallback.  Implementations generally prefer displaying the raw text of a User
ID over hiding the content or even the entire identity, making assumptions on
its length and meaningfulness to humans.  Using a URI in place of this data
would thus lead to a perceived display of technical data that is meant for
further processing, breaking assumptions of implementations and, ultimately,
confusing users.  For this reason, it makes sense to open up a distinct
namespace of information, defaulting to an opaque or hidden display of packets.

One drawback of this design decision is the loss of search capabilities on
keyservers.  Since User IDs are full-text searchable on SKS Keyservers (see
\Fref{sec:keyservers}), incorporating URIs in these packets would make them
searchable with no further implementation overhead.  However, this
implementation overhead is presumably low, since the necessary routines are
already present and would only need to be extended to also handle the new User
Attribute type.  Support for Linked Attributes in keyservers is not a part of
this thesis, and left to further work (see \Fref{sec:further-work}).

*** Linked Identity URIs
<<sec:linked-id-uris>>

Having established a User Attribute which can contain a URI, we define in this
section a scheme which defines all semantics and operations necessary to express
and maintain a trust link.  The contents of this section reproduce the Internet
Draft "Linked Identities for OpenPGP" \cite{draftvblinkedids}, adding discussion
on design decisions where appropriate.  If accepted, this proposed standard will
register the =openpgp+token= URI scheme as a provisional scheme conforming with
the relevant IETF Best Current Practice document on new URI schemes, RFC 4395
\cite{rfc4395}.  See Appendix \ref{appendix:linked-ids} for the full draft.

**** Scheme Design

We identify a number of design criteria for our URI scheme:

1. The semantics of the URI should, in the context of a URI Attribute, be
   precisely those of a Linked Identity.  More specifically, the URI should
   express a trust link from the OpenPGP key to the Linked Resource, and at the
   same time state a claim that the Linked Resource also publishes a trust link
   to the OpenPGP key.

2. Allow specification of additional parameters for retrieval.  The decision to
   use URI Attributes implies that no additional parameters can be specified in
   the OpenPGP packet, which means that those parameters must be encoded in the
   contained URI itself.  See \Fref{sec:uri-attribute-rationale} for a
   discussion on this decision.

3. The Linked Resource should be of a synchronously retrievable type to its
   target audience.  This excludes, for instance, e-mail addresses, which are a
   valid type of Linked Resource, but which point to a message sink rather than
   to a retrievable resource.  This choice was made to distinguish types of
   Linked Resources by their type of retrieval, and put the focus on retrievable
   ones.

Following these criteria, we introduce the "=openpgpid+token=" scheme to be used
in Linked Attributes.  This scheme opens the namespace =openpgpid= of URI
schemes which express a trust link from the OpenPGP key they occur in to the
Linked Resource they refer to (1).  The scheme also adds the specialization
=+token= within this namespace, which expresses that the URI is simultaneously a
claim of control which is expected to be confirmed by the Linked Resource
itself, in a way which is accessible to its target audience in a synchronous
fashion (3).

Giving a comparison for intuition, the "=openpgpid=" scheme on its own expresses
the same semantics as a regular OpenPGP User ID packet.  A User ID which
contains the address "mail@example.com" could be considered roughly equivalent
in semantics to a URI Attribute with the (hypothetical) URI
=openpgpid:mailto:address@example.com=.  See \Fref{sec:uri-attributes-uid} for
details on the decision to use User Attributes over User IDs regardless.

Before we proceed with the definition of the scheme and its semantics, we define
a number of terms:

- A /Linked Identity URI/ :: is a URI where the scheme has a defined meaning in
     terms of a Linked Identity.

- A /Linked Attribute/ :: is a URI Attribute which contains a Linked Identity
     URI.  The general semantics of a Linked Attribute, like the URI Attribute,
     are defined by the scheme of its URI, and in particular requires support
     for a newly introduced operation called the VERIFY operation.

- The /VERIFY/ operation :: is an operation defined on a Linked Identity URI
     which tests the validity of the Linked Identity, i.e., the existence and
     validity of both trust links from the OpenPGP key to the Linked Resource
     and back. The precise mechanics of the VERIFY operation are defined by the
     particular URI scheme and may, for the sake of flexibility, not have a
     generic mechanism even for a defined scheme.  See
     \Fref{sec:linked-id-verify}.

- A /Linked Resource Token/ :: or Linked Token is a token placed at the Linked
     Resource site, which refers back to the OpenPGP keyring in an unambiguous
     way, thus expressing a trust link from the resource to the key.  It is
     retrieved and processed by the VERIFY operation.  See
     \Fref{sec:linked-id-token}.

**** Direct Use of Linked Resource URIs

We already require that Linked Resources are uniquely identifiable by URIs (see
\Fref{sec:requirements}).  The subset of these URIs which have a protocol which
supports some sort of retrieval operation (thus fulfilling requirement 3, see
previous section) could be used directly in URI Attributes.  This is still a
less desirable option for multiple reasons though:

- Linked Resource URIs do not on their own imply their semantics as a trust
  link.  Another way to fulfill requirement 1 (see previous section) would be
  incorporating this notion into the User Attribute packet itself, however this
  loses the advantages of a generic URI Attribute type. (see
  \Fref{sec:uri-attribute-rationale}).

- Part of the specification of a URI are its applicable set of operations (RFC
  4395 \cite{rfc4395}, Section 2.4).  For the case of Linked Identity URIs, the
  usual semantics of Linked Resource URIs do explicitly not apply, defining
  different semantics instead.

- Support for flags and parameters (requirement 2) would need to be moved into
  the the packet type, adding complexity.  It is also the common case for a
  Linked Attribute to have no flags or parameters, so it makes sense to optimize
  for that.

**** Scheme Grammar

The =openpgpid+token= scheme is defined in Augmented Backus-Naur Form (ABNF)
\cite{rfc5234} as follows:

:   linked-uri  =  scheme ":" [options] "@" <absolute-URI>
:       scheme  =  "openpgpid+token"
:      options  =  ( option / flag ) [";" options]
:       option  =  key "=" value
:         flag  =  key
:          key  =  *(<unreserved>)
:        value  =  *(<unreserved> / <pct-encoded> / ",")

Where the grammars for <absolute-URI>, <unreserved> and <pct-encoded> are
defined as in RFC 3986 \cite{rfc3986}:
- <absolute-URI> :: is a full absolute URI, starting with a scheme name.
- <pct-encoded> :: is a percent-prefixed hex-encoded UTF-8 character as commonly
                   used in URIs, e.g., "%61" for ASCII character 0x61, which is
                   the ASCII character 'a'.
- <unreserved> :: are characters which have no special meaning in URIs,
                  specifically all alphanumeric characters plus hyphen "-",
                  period ".", underscore "_", and tilde "~".

One aspect for the specification of a URI scheme are encoding considerations.
Resulting from the definition of the URI Attribute, the encoding of URIs which
use this scheme is fixed to UTF-8 (see \Fref{sec:uri-attributes}).  While the
flag and option part of the URI use a restricted character set from which no
encoding issues should arise, considerations of the Linked Resource URI must be
taken into account.  It is generally the job of the issuer of a Linked Attribute
to make sure the encoding is compatible, others who process it may safely treat
encoding errors in a fail-fast manner.

**** Scheme Semantics
<<sec:lid-scheme-semantics>>

The =openpgpid+token= scheme consists of a wrapped absolute URI, plus any
number of flags, plus any number of pairs of key-value options.

The usual semantics and operations of the wrapped URI explicitly do not apply.
Instead, the scheme defines the VERIFY operation, which if successful yields a
result on the validity of the Linked Identity.  This operation is defined in the
context of the OpenPGP key the Linked Attribute appears in, and is applied to
the wrapped URI, parameterized by the given flags and options.

Flags and parameters may specify retrieval or parsing parameters which restrict
the range of valid ways to retrieve or parse the token, e.g., by requiring use
of a specific /pinned/ certificate for retrieval over a TLS-secured connection.
For this reason, a URI of this scheme must always be parsed and interpreted as a
whole, an implementation should not make use of any sort of partial information.
This means in particular that if any flag or option is unknown to an
implementation, the entire Linked Identity URI must be treated as not supported.

It is important to note that the terms "validity" and "verification" in the
context of a Linked Attribute are tied to the VERIFY operation.  This is not to
be confused with the validity of the self-certification on the Linked Attribute,
which is always required for a packet to be considered a Linked Attribute in the
context of an OpenPGP key in the first place.

**** Linked Resource Token
<<sec:linked-id-token>>

In order to define the VERIFY operation, we first specify a format for Linked
Resource Token.

A Linked Identity Token must unambiguously refer to the OpenPGP key.  This is
the only strict requirement, which makes the full 20 bytes fingerprint the
minimum amount of data suitable as a token, respectively the 40 character
representation as a string of hexadecimal digits.  The more complicated
requirement is that a Linked Identity Token should be recognizable as such to a
user.  Tokens are often used in a human-facing context, for example in messages
or profile data, but may not be perceived as a security-critical operation.
Since creating a trust link to an OpenPGP key is as easy as publishing a message
which contains a Linked Identity Token, this reflects on the difficulty of a
social engineering attack.  For this reason, a token should at least bear a
strong hint that it is a cryptographically significant piece of data or,
preferably, imply its meaning as accurately as possible.

To cover this recommendation, we introduce a suggested format for Linked
Resource Tokens.  This format (see \Fref{ex:linked-id-token}) was designed to
fulfill the above requirements of human recognizability.  It is also delimited
by brackets to make its beginning and end obvious to the user.  The format is
defined in ABNF as follows:

: token       = "[" "Verifying my OpenPGP key " tokenuri  "]"
: tokenuri    = "openpgp4fpr" ":" fingerprint
: fingerprint = 40*<HEXDIG>

The =tokenuri= rule follows the =openpgp4fpr= scheme, which unambiguously
identifies an OpenPGP key by its (OpenPGP version 4) fingerprint.  This scheme
was originally proposed by the Monkeysphere[fn:monkeysphere] project
\cite{openpgp4fprproposal}.  It has since gained some traction, particularly for
key exchange via QR-Code in Android-based implementations of OpenPGP, and was
also accepted by the Web Hypertext Technology Working Group (WHATWG) to the
whitelist of schemes[fn:whatwg-whitelist] in browsers to which handlers may
freely register.  Its use in Linked Resource tokens allows clients which are
aware of the URI format to connect the text with an action, presumably opening a
dialogue to import the referenced key.

\begin{example}[t]
    \centering
    \texttt{[Verifying my OpenPGP key openpgp4fpr:d4ab192964f76a7f8f8a9b357bd18320deadfa11]}
    \caption{Example of a Linked Resource Token}
    \label{ex:linked-id-token}
\end{example}

This token format is only a recommendation.  If for some reason a token cannot
be placed at a site in this format --- for example due to a restricted available
character set --- it may be encoded in a encoding scheme which should be simple
and reasonable.  An exemplary transformation would be by trivially (but
unambiguously) translating the restricted characters, and it is recommended to
retain human readability as well as possible.

For resource sites which are not human readable by nature at all, an
implementation may accept Linked Resource Tokens which consist of the encoded
fingerprint only.  Because of the aforementioned risk of social engineering
attacks, this should only be allowed with careful consideration.

**** The VERIFY Operation
<<sec:linked-id-verify>>

The VERIFY operation on Linked Attributes verifies the link between an OpenPGP
key and a Linked Resource, similar to the computer review in the Keybase
implementation (see \Fref{sec:keybase-id-proof}).  Performed on an
=openpgpid+token= URI, the operation consists of two distinct parts, retrieval
and evaluation.

To retrieve the Linked Resource pointed to by an =openpgpid+token= URI, the
resource referred to by the wrapped URI is requested.  The mechanism for
retrieval does not have to conform with the scheme of the URI if the semantics
of the URI can be interpreted for retrieval otherwise.  If available,
implementations are encouraged to use the API of a website to retrieve Linked
Resources, which is a clean and safe way compared to parsing the website the
wrapped URI refers to directly and extracting the token from it.

Similarly, it is not safe for implementations to retrieve Linked Resources where
the exact semantics are not known by using a generic "scraping" mechanism,
unless specifically instructed to do so.  Even if it is technically possible to
retrieve the contents of a wrapped URI (e.g., for the =https= scheme), this is
unsafe because a correct VERIFY operation might require additional insight on
the contents of the website to reliably extract the Linked Resource data.  For
example, profiles on social media websites may include comment sections or other
parts which are not entirely user-controlled, and thus require extraction of the
specific, owner-controlled part.

The particular mechanisms for requesting and extracting the token may be
specific to the entire Linked Identity URI, including flags and options. Flags
and parameters may be used to alter the semantics of Linked URIs in arbitrary
ways, e.g., by introducing additional conditions on the retrieval method, or
changing the meaning of the URI itself.  The use case of a website retrieved in
a generic way is actually a special case of Linked Resource and is one use case
where a flag can be used to alter wrapped URI semantics (see
\Fref{sec:impl-website}).

For the evaluation of the retrieved token, the retrieved data is matched against
the expected token for the given OpenPGP key.  During this process, the
implementation may apply transformations or matching criteria at its own
discretion.  This wiggling room in matching should be kept as small as possible,
since the properties of a Linked Identity depend on the reliability of the
URI-specific mechanism for verification.  What is acceptable in a token is
ultimately up to the policy of the verifying implementation, not the one which
creates the Linked Resource.  For this reason, it is very important that this
mechanism is robust against false positives, and strictly enforces aspects of
the token it deems important.  One such aspect is the human-readable part, which
should not be allowed to be left out unless there is good reason to, such as
size constraints.  This approach explicitly diverts from Postel's law "be
conservative in what you do, be liberal in what you accept from others"
\cite{rfc761}, an implementation should be very conservative about what is
accepted as a valid Linked Resource Token.

Giving precise interpretations on the URIs of Linked Resource types is out of
scope for the specification, which for this reason does not provide specifics on
the semantics of particular instances of Linked URIs, nor does it define any
flags or parameters.

*** Certification
<<sec:linked-id-cert>>

The draft on Linked Attributes defines certifications on this type of identity
slightly more strictly than on other packets: A compliant implementation must
not issue a certificate over a Linked Attribute without a positive result from a
VERIFY operation performed on its URI, but it may issue one based on the result
of a VERIFY operation exclusively.  Conversely, an implementation should not
assume that certificates make any statement about the genuineness of the Linked
Resource or the key itself other than the success of the VERIFY operation.

Linked Identities diverge from established certification practices in this way,
since the assumptions which can be drawn from foreign certifications issued for
Linked Identities have a defined upper bound; Specifically, an implementation
must not assume a certification to have any more meaning than the success of the
VERIFY operation.  This affects a possible trust model in two ways: Firstly, the
certificates issued by foreign keys should only be regarded as evidence for the
validity of the Linked Attribute, not of the genuineness of the Linked Resource
or the key owner.  Secondly, it encourages automated services to issue
certifications for Linked Attributes for which the VERIFY operation yielded a
positive result.

As a means of authentication, Linked Identities are a vector for MitM attacks.
The difference between the verification of a Linked Identity and the
authentication of the owner of a key in particular may be non-obvious to users.
While a certificate may be issued and published based on the VERIFY operation
alone, the decision of whether the key as a whole is trustworthy must at some
point take into account the genuineness of the Linked Resource.  As with all
certification processes, the user should be provided with sufficient guidance to
be able to make an informed decision.  See \Fref{sec:attack-scenarios} for a
discussion on the attack surface introduced by Linked Attributes.

*** Perspectives
<<sec:lid-perspectives>>

During retrieval, the resource as it is actually delivered by the server must be
taken as initially correct, which means there is no direct way for an
implementation to protect against attacks which compromise the site of the
resource itself.  An effective measure to increase confidence in the Linked
Token is through spatial and temporal redundancy, i.e., finding proof that the
server delivers the same Linked Token not only to the current client, but also
to other clients at other places in the network and points in time.

# pull up widow line
\enlargethispage{\baselineskip}

A mechanism for this is technically achievable with Linked Attributes in a
simple way: Certificates over Linked Attributes may be shared as part of the
OpenPGP key they were issued for via keyservers, just like any other signature
packet.  This means information is available to the implementation at the time
of certification what other known keys already verified a Linked Attribute.
This information can be displayed to the user as additional information during
certification, or even made mandatory for certification.  Since certificates by
other keys are used only as auxiliary information to increase confidence that a
Linked Resource is genuine, not for positive verification, certificates used in
this way require less trust than those used for a WoT mechanism.

This concept is equivalent to the application of /perspectives/ to Linked
Attributes, a concept originally introduced by Wendlandt et al. as an extension
to the TOFU-based security used in SSH \cite{wendlandt2008perspectives}, and
implemented for the X.509 PKI as the "Perspectives
Project"[fn:perspectives]. The general idea of perspectives is to have
independent notary servers on the network, which keep a log of (relevant parts
of) responses offered by a particular server from their point of view in the
network, in this case the public key fingerprints of certificates used by the
hosts to identify themselves.  Identifying with different public keys to
different clients is not a reasonable use case for either an SSH or HTTPS
server, but more likely a targeted attack.  Allowing a client to compare their
received fingerprint with one received from a different perspective provides an
additional way to falsify the key, contributing to the confidence in its
validity.

* Implementation
<<chap:implementation>>

As a part of this thesis, we implemented a working prototype of Linked
Identities based on User Attributes in OpenKeychain, which is an OpenPGP
implementation for the Android platform.  In this chapter, we first outline the
design process and required backend changes to add support for User Attributes,
then describe the newly required user interface elements and dialogs and how
they were implemented.

The reader is assumed familiar with Java, and the basic terms of the Android and
Material design frameworks.

** Overview of OpenKeychain

\begin{wrapfigure}{l}{0.12\textwidth}
  \centering
  \includegraphics[width=0.11\textwidth]{images/logo-openkeychain}
\end{wrapfigure}
OpenKeychain is an OpenPGP implementation for Android, which was released in
2013 as a fork of APG, and aims to be fully compatible to RFC 4880
\cite{rfc4880}.  It uses BouncyCastle as a backend for cryptographic operations
and OpenPGP compatibility (see \Fref{sec:impl-bc}).

The primary focus of OpenKeychain is on key management, with direct support for
cryptographic operations on files only as a secondary goal.  Instead, an
interface is provided for other applications to make use of the cryptographic
operations using a high-level API, which makes all user interaction required for
key management transparent to the client application.  In this way, OpenKeychain
fills the same role on Android as GnuPG does on other platforms.

*** Design and Code Patterns
<<sec:ok-patterns>>

In this section, we give a brief overview about design and code patterns
employed in OpenKeychain, which are necessary to understand some of the design
decisions made later in this chapter.

OpenKeychain has a fairly strict distinction between frontend and backend code.
Frontend code is everything related to the user interface and experience, this
part is designed around the Android framework and is thus very
platform-specific.  The backend on the other hand is responsible for parsing and
internal management of keys, the database layer, and cryptographic operations.

# pull up widow line
\enlargethispage{\baselineskip}

As a further distinction in the backend code, Android related and cryptographic
code which uses BouncyCastle objects are kept separate and independent where
possible.  For this reason, class imports from the BouncyCastle library are
restricted to those classes in the =pgp= package in the main package of
OpenKeychain, all other parts of OpenKeychain use the wrappers from this
abstraction layers for operations on OpenPGP objects exclusively.  Imports of
Android classes are avoided in cryptographic code and in the =pgp= package in
particular, although this requirement is not as strict.

A code pattern which is used throughout OpenKeychain is that all complex
operations return an instance of a specialization of the =OperationResult=
class.  This base class contains a result status, a log of operations, can be
displayed as a notification to the user, and is designed to be /parcelable/,
which is a type of serialization used on Android.  Each operation has a
specialization of this class, which adds the particular result semantics of the
operation.

** Backend

As a first step, support was added in OpenKeychain to correctly import Linked
Attributes and provide an interface to their data for the user interface
components.  To this end, support for User Attributes was first implemented in a
generic way, followed by classes to parse Linked Attributes and perform all
required operations on them.

*** User Attribute Support

The latest version of OpenKeychain available at the beginning of this thesis
(version 3.1, released October 27th) did not feature creation, modification or
display of Photo IDs or other User Attributes.  We add these features by
changing the database structure to include information on User Attributes, and
add support to the import and key editing routines.  All changes in this section
have been merged into the main branch of OpenKeychain development, and were
included in the 3.2 release of OpenKeychain on May 6th.  This does not include
any changes to the user interface, but purely the internal handling of User
Attributes during import of keys.

**** Database

#+BEGIN_figure
    \centering
    \includegraphics[width=0.80\textwidth]{images/ok-schema}
    \caption{Database Schema in OpenKeychain with Modifications} \label{fig:ok-schema}
#+END_figure

The internal structure of the keyring maintained in OpenKeychain uses a content
provider to store and retrieve information about keys.  From this provider, data
can be accessed via content URIs, which are translated into parameterized
queries to the underlying SQLite database.

The SQLite database contains the binary data of public and secret OpenPGP keys
in one table each, and also structured information about their subkeys,
identities and certificates, where most rows are identified by their association
to the public key using their 8 byte Long Key ID (see \Fref{sec:key-ids}).  As a
fundamental design decision, all data besides the binary key data has a direct
dependency on this data, and is only stored externally for increased
accessibility through the content provider.  No extra data is stored in the
database.  In this sense, the database forms a caching layer around the stored
OpenPGP keys, and can be fully reconstructed only from the binary key data.

The database schema contained a table "user_ids", which stored data about the
user ids of all keys. The individual ids in this table are identified as a weak
entity by the master Key ID of the key they belong to and a rank column, which
is a simple incremental index number per key.

We make the simplifying assumption that each User Attribute packet contains only
a single subpacket type, or that at least only the type of the first subpacket
is relevant.  With this assumption, User Attributes have in comparison to User
IDs only two additional points of data, more specifically one column for their
type ID, and one for the binary data contained in the attribute.  This leads to
a simple way to generalize the "user_ids" table to a "user_packets" one by
adding a type column and a data column, asserting that the type ID field is NULL
iff the referenced identity is a User ID (see \Fref{fig:ok-schema} for an
overview).  Since the database is accessed exclusively via the content provider
in OpenKeychain, compatibility can trivially be established by renaming all SQL
queries to the "user_ids" table to query the "user_packets" table instead, and
adding "type_id IS NULL" as a logical conjunction to their WHERE clause.

The "user_id" field is preserved as a string field to retain searchability of
user ids, and is set to NULL for User Attribute entries.  The "packet_data"
field contains the raw binary data of the User ID or User Attribute packet,
introducing a minor amount of redundancy for User IDs, which is offset by the
newly gained capability to retrieve the User ID packet data independent of its
encoding.

Since User Attributes are treated analogously to User IDs in terms of
certification, storage of information on User Attribute certificates follows
from the design without any modification of the "certs" table (see
\Fref{fig:ok-schema}).

**** Import

Since User IDs are simple string objects (or possible byte
arrays), they require no wrapping class.  User Attributes are more complex
objects, so we add a class WrappedUserAttribute to the abstraction layer which
contains the binary data of a User Attribute and can be obtained from the
wrapping key classes, and support all necessary operations on User Attributes.

The import routine is split into three steps:
1) If the key is already known, the new material is merged with the old one,
   creating a key which contains all packets from both versions.
2) The merged key is /canonicalized/.  During this step, the self-signatures on
   all identity and subkey packets are checked for validity, removing all
   incoherent data.
3) If the key already existed in the database, it is deleted entirely.  The
   canonicalized key is then inserted, filling the tables on identities,
   certificates and subkeys with all relevant information.

All three steps require modification to work with User Attributes.  However
since the underlying BouncyCastle implementation already provides the necessary
data types, and User Attributes are treated analogously to User IDs for most
intents and purposes, the existing routines for User IDs needed only be copied
and slightly adapted to work with User Attributes in all steps, requiring no
further significant design decisions.  In particular, the trust model for User
Attributes was created in a way that is identical to the one for User IDs.

**** Key Editing

With the above changes, User Attributes are now respected during import,
available to the user interface through the content provider, and accessible
from wrapped OpenPGP key objects through the WrappedUserAttribute class.  To
complete generic User Attribute support in the backend, the only missing part is
support in key editing routines.

All key editing features are centralized in OpenKeychain in the
=modifySecretKeyRing= routine of the =PgpKeyOperation= class, which takes as
parameters a reference to the key to operate on, and a =SaveKeyringParcel=
object (in BouncyCastle, the word 'keyring' is used to refer to an OpenPGP key).
The class of this object is designed to hold a representation of all operations
to be applied to a key in a serializable fashion with a unified interface.  For
User IDs, it contains a list of User IDs to be added, and a list of User IDs to
be revoked in the key.  We add the same lists for the WrappedUserAttribute
class, and the appropriate handling in the =PgpKeyOperation= class.

It is notable that User IDs as well as User Attributes are identified by their
entire content for purposes of key merging.  This means that it is not possible
to add two User IDs or Attributes with the same content, and on the other hand
that the content is used to identify the correct packet in a key.  This is
important for revocation, where the attribute data itself is passed rather than
a reference to the particular packet in the key which is to be revoked.  For
both creation and revocation, the actual operation performed is that a signature
a signature is generated over the packet data, which is then either merged after
the existing attribute with the same data or added together with the attribute
packet as a new one.

**** Unit Tests

Backend operations in OpenKeychain which perform operations on OpenPGP keys are
tested by a suite of unit tests as part of the build process.  In particular,
the routines for canonicalization, merging, and editing are subject to extensive
testing (roughly 2500 lines of code).  To ensure compatibility and reduce the
possibility of regressions introduced by our implementation of User Attributes,
we modified the unit tests for each of these routines to include User Attributes
in the keys during all tested operations.  We also added specialized tests for
creation and revocation of User Attributes in existing keys.  All User
Attributes used for testing are generated using random data for both type and
content, which is checked for integrity before all tests, and again after a
selected number of tests.

*** Linked Identity Support

As the second part of backend support for Linked Identities, a component has
been created to support parsing of Linked Attributes from User Attribute data
and perform relevant operations on these data structures.

This component is implemented with reusability and extensibility in mind, as a
relatively small and independent java package.  No BouncyCastle imports were
used, and only the minimum amount of imports from Android packages.  The only
case where such imports could not be reasonably avoided were related to logging
and referencing user interface resources from the Android ecosystem.

Two related hierarchies of classes are introduced: one for handling URI
Attributes and their Linked Attribute specialization, and one for Linked
Resources (see \Fref{fig:uml-linked-ids}).  The =openpgpid+token= scheme
introduced in \Fref{sec:linked-id-uris} is the only type of Linked URI
recognized at this point.

The routines in this package are completely agnostic of the User Attribute
certification life cycle, all checking of signature data in OpenKeychain is done
during import, except for expiry which is stored in the database.

#+BEGIN_figure
    \centering
    \includegraphics[width=\textwidth]{images/uml-linked-ids}
    \caption{Linked Identities Class Diagram (simplified)} \label{fig:uml-linked-ids}
#+END_figure

**** The URI Attribute Hierarchy
<<sec:backend-uri-attrib>>

The URI Attribute hierarchy consists of only two classes, UriAttribute and
LinkedAttribute, where the latter is a specialization of the former.  All
instances of the UriAttribute class contain a valid URI.  Since the only type of
supported URI are Linked URIs, a proper instance of this class represents a URI
which could be parsed as such, but where the scheme is unknown or the type of
LinkedResource could not be fully parsed.  The LinkedAttribute subclass is a
specialization which adds a reference to the Linked Resource as parsed by the
appropriate subclass of the LinkedResource hierarchy.

The main entrypoint of interaction for the URI Attribute hierarchy is the static
method =fromUserAttribute= in the UriAttribute class, which takes a
WrappedUserAttribute object and first tries to parse it as a Linked Identity, or
falls back to a UriAttribute instance in case of failure. There are three
possible cases for the returned object:
- If the WrappedUserAttribute contained a Linked URI which could be correctly
  par\-sed as a Linked Resource of a known type, the returned object will be an
  instance of the LinkedAttribute class.
- If the WrappedUserAttribute contained a well-formed URI where the scheme is
  unknown, or where no Linked Resource type could fully parse all parameters,
  the returned object is a UriAttribute.
- If none of the above cases apply, i.e., the URI is malformed in some way, the
  returned object will be =null=.  This is most likely to happen if the packet
  contains binary data, which is a more likely occurrence while URI Attributes
  use a User Attribute ID from the experimental range rather than their own one.
  If URI Attributes become part of the standard, this case could be treated more
  helpfully as a "malformed URI" rather than "unrecognized packet" error.

The content of all instances of the UriAttribute class are defined entirely by
the URI they are created from, and are immutable for the lifetime of the object.
Since parsing is an expensive operation, parsed instances of the UriAttribute
class are cached by URI in the =fromUserAttribute= method.

# further work: better partly recognition?

**** The Linked Resource Hierarchy

The LinkedResource hierarchy provides a parsing layer over Linked URIs for all
supported types of Linked Resources.  The hierarchy root is the abstract
LinkedResource class, which exists to provide a general interface to Linked
Resources, it fulfills no purpose other than extensibility at this point.  The
LinkedTokenResource subclass represents a parsed =openpgpid+token= URI, split
into flags, parameters and a wrapped URI.

Supported types of Linked Resource are represented as concrete subclasses of
LinkedTokenResource, which each parse and store their respective
resource-specific parameters.  Instances of the LinkedTokenResource classes are
obtained through the =fromUri= static method, which returns either an instance
of a concrete subclass of itself, or =null= if none could be found.  Internally,
the passed URI is broken down into flags, parameters and its wrapped URI, then
passed as these three parameters to the static =create= method of each resource
type.

The implementation in its current state makes no effort to display information
to the user about Linked URIs which are not fully understood, other than their
existence as part of the key.  In accordance to the specification (see
\Fref{sec:lid-scheme-semantics}), this includes both the structure of the
wrapped URI, and all flags and parameters.  Since this distinction happens on
the URI Attribute layer (see below), there is no need for generic instances of
the LinkedTokenResource class, it is hence also declared abstract.

**** Linked Resource Verification

The VERIFY operation is split up into two parts: retrieval and matching.  To
avoid code duplication and keep the process streamlined for all resource types,
most of the control flow is implemented in the =verify= method of the
LinkedTokenResource class.  Like other complex operations in OpenKeychain, this
method keeps a log of its operations and returns LinkedVerifyResult, which is a
specialized subclass of OperationResult (see \Fref{sec:ok-patterns}).

#+BEGIN_figure
\begin{verbatim}
    \[Verifying my (?:Open|)?PGP key(?::|) openpgp4fpr:([a-zA-Z0-9\]+)]
\end{verbatim}
    \caption{Regular Expression used for default Matcher} \label{fig:matcher-regex}
#+END_figure

To perform the VERIFY operation (as defined in \Fref{sec:linked-id-verify}) on a
concrete LinkedTokenResource object, the =verify= method is called, with the
fingerprint to verify against as a parameter.  This method first calls the
abstract =fetchResource= method, which is responsible for retrieval and
extraction of the Linked Token from the referenced resource.  This string is
passed on to the internal method =verifyString=, where the retrieved string is
passed to the =matchResource= method, which returns a Matcher object from a
regular expression on the resource string (see \Fref{fig:matcher-regex}).  If
this Matcher returns success on matching the pattern against the token, and the
first matching group is successfully tested for string equality against the
fingerprint, the method returns a success.

The control flow of the =verify= method is designed to cover the general case,
but allow for flexibility in particular aspects for subclasses.  The
=fetchResource= method is entirely specific to the resource and must be
implemented by each concrete subclass, while other methods like =verifyString=
or =matchResource= can be overridden to change their behavior from the default,
if so required for a resource type.  For maximum flexibility, the =verify=
method itself can be overridden, though this was not necessary for any
implemented resource.

**** Linked Resource Creation
<<sec:impl-backend-creation>>

The control flow for the creation of Linked Identities requires a lot of user
interaction, and is thus driven by the user interface code, which calls to the
backend to perform specific operations only.  From the backend perspective,
there are three relevant steps for the creation of a Linked Resource:

- Generation of the Linked Token text. ::  The token format varies only rarely
     by resource type.  It is obtained from the static =generate= method which
     is available from LinkedTokenResource, but may be overridden for resource
     specific token formats.

- Publishing the resource. :: The publishing itself very much depends on the
     methods available for the type of resource, it is either a simple task
     performed by the user or involves delegation to other apps via Android
     interfaces, neither of which involve the backend.  Some resources offer a
     method for finding the URI of a Linked Resource once it has been created,
     e.g., from a social media profile's public message stream for a given
     account handle.

- Creation of the Linked Attribute. :: Once the resource is created and
     published, a LinkedTokenResource class can be obtained for the Linked
     Attribute.  This is done using the static =create= method, which is usually
     passed the URI of the referenced resource, but may take other or more
     parameters depending on the type.

** User Interface

The User Interface side of the implementation adds three Linked Identity related
UI components: One for creation of new Linked Identities, one for listing them
alongside User IDs, and one to verify and subsequently confirm (i.e., certify)
them if the user is convinced they are genuine.

#+BEGIN_figure
    \centering
    \begin{subfigure}[b]{0.48\textwidth}
        \centering
        \includegraphics[width=0.80\textwidth]{images/overview}
        \caption{The ViewKeyActivity in OpenKeychain}
        \label{fig:ok-viewkey}
        Red rectangles emphasize areas which were modified for this thesis.
    \end{subfigure}
    \begin{subfigure}[b]{0.48\textwidth}
        \centering
        \includegraphics[width=0.80\textwidth]{images/shot-wizard-http3}
        \caption{Linked Attribute Wizard}
        Shown is creation step 3 for a Website (TLS) resource.
        \label{fig:shot-wizard-http3}
    \end{subfigure}
    \caption{OpenKeychain Screenshots}
#+END_figure
#+BEGIN_figure
#+END_figure

# pull up widow line
\enlargethispage{\baselineskip}

Two user interface elements have been added to the layouts used in the
ViewKeyActivity layout files.  The first is a menu item "Add Linked Identity" in
the context menu (upper right of \Fref{fig:ok-viewkey}) to create a new Linked
Identity, which shows up for secret keys of the user only.  The second is a card
view in the main content area (bottom center of \Fref{fig:ok-viewkey}), which
lists Linked Identities for the key, and also provides an entrypoint for a
verification and confirmation workflow.  These two are the only direct changes
to OpenKeychain layout files.

*** Creation

For the creation of new Linked Identities associated with one of the user's
keys, an Android Activity with a wizard-style interface was created.  As is
common in wizards, each step is a full screen dialogue, with "Back" and "Next"
buttons at the bottom to navigate.  The wizard is divided into three steps, and
tries to follow a uniform user interface flow for all supported resource types.
There is also relatively much text on each page, explaining the current step to
the user.  \Fref{fig:shot-wizard-http3} shows the second and final step for the
creation of a Website (TLS) Linked Attribute.

The initial wizard step simply gives the user a choice between all Linked
Resource types in a simple list.  All types of Linked Identity which are
supported in listing and verification can also be created in this Activity (see
\Fref{sec:ok-linked-impl}).

The second step asks the user for a resource-specific location where they intend
to place the Linked Resource.  This is not usually the full URI yet, but
typically an account handle or domain name.

In the third and last step (see \Fref{fig:shot-wizard-http3}), the user is first
provided with an action to "share" the resource.  This share action uses Android
framework mechanisms to send the user to the correct dialogue for sharing the
resource in its related app, if any is available.  Where not available, the user
is provided with instructions on how to place the resource, this work flow is
only intended as a fallback for more advanced types of resources.  After the
resource is shared (i.e., published), the user can press a button to verify that
the resource is correctly placed.  During this verification, the actual URI of
the Linked Resource is obtained, searching the location provided earlier (see
\Fref{sec:impl-backend-creation}).  Once successful, the user can finish the
operation, which creates the Linked Attribute, adds it to their key, and uploads
it to the keyservers.

*** Listing

#+BEGIN_figure
    \centering
    \begin{subfigure}[b]{0.48\textwidth}
        \centering
        \includegraphics[width=0.85\textwidth]{images/shot-lid-expanded}
        \caption{Verified Twitter, and Unknown Identity}
        \label{fig:shot-lid-expanded}
    \end{subfigure}
    \begin{subfigure}[b]{0.48\textwidth}
        \centering
        \includegraphics[width=0.85\textwidth]{images/shot-lid-collapsed}
        \caption{Unconfirmed Twitter Identity, and\\expander for Unknown Identity}
        \label{fig:shot-lid-collapsed}
    \end{subfigure}
    \caption{Linked Identity Cards}
    \label{fig:shot-lid-both}
#+END_figure

Linked Identities are listed in the "ViewKeyActivity" in their own card element,
similarly and next to User IDs (see \Fref{fig:ok-viewkey}).  This functionality
is added directly into the ViewKeyFragment class of OpenKeychain.

# push orphan line to next page
\clearpage

Most of the work happens in a class called LinkedIdsAdapter.  This class takes
as input a Cursor over all URI Attribute rows from the database for a given key,
and maps them to item view elements for a ListView (see
\Fref{fig:shot-lid-both}).  For this, each row of data is parsed into a
UriAttribute object.  This class exposes three "getter" methods for the user
interface, namely =getDisplayIcon=, =getDisplayTitle=, and =getDisplayComment=.
The return values of these methods all depend on the Android user interface
context, and return a reference to an icon for the resource type, a localized
title line meant for the resource type, and a slightly smaller and optional
comment line, intended for resource-specific information such as an account
handle or similar.  Clicking on an item expands the card into details about the
clicked Linked Identity where the user can view, verify, and confirm the
identity (see next section).  In the UriAttribute class, the return values of
the UI getters are hardcoded to "Unknown" values, the LinkedAttribute class
simply delegates the calls to its contained LinkedResource.

To the right of each item is an indicator of its signature confirmation status.
This status indicator distinguishes between a confirmed, unconfirmed, expired,
and revoked status.  Since the meaning of certifications on User Attributes is
identical to those on User IDs (see \Fref{sec:linked-id-cert}), this indicator
also behaves analogously.

Listing of unknown identities has been implemented.  Those identity types are
usually hidden, but add an expander to the bottom (see
\Fref{fig:shot-lid-collapsed}), which if clicked expands the listing to include
identities of unknown types.  Since URI Attributes which are not parseable as
Linked Attributes can be expected to be erroneous at this point, and if shown in
a purely informative way would arguably confuse users more than it would help
them, this feature was ultimately disabled and unknown URI Attributes are now
simply hidden.

The display of this list involves parsing of all URIs into LinkedAttribute
objects, which is a relatively expensive operation to be performed on the UI
thread.  This is somewhat mitigated by the caching which is done internally in
the parsing routine of the UriAttribute class (see
\Fref{sec:backend-uri-attrib}).

*** Verification
<<sec:impl-verification>>

Verification of identities happens in its own card view in ViewKeyActivity, and
is available by clicking any Linked Identity (see previous section).  The card
view is maximized and occupies an element on the FragmentManager stack, i.e., it
is displayed as the only card view, and the back button can be used to return to
the list of identities in the key.  The card view is implemented in its own
LinkedIdViewFragment class, while fragment management is added to the
ViewKeyActivity it is displayed in.

#+BEGIN_figure
    \centering
    \begin{subfigure}[b]{0.40\textwidth}
        \centering
        \includegraphics[width=0.90\textwidth]{images/shot-verify}
        \caption{Detail View}
        \label{fig:shot-verify}
        \vspace{0.5cm}
    \end{subfigure}
    \begin{subfigure}[b]{0.40\textwidth}
        \centering
        \includegraphics[width=0.90\textwidth]{images/shot-verify-ok}
        \caption{Successful Verification}
        \label{fig:shot-verify-confirmed}
    \end{subfigure}
    \caption{Verification Card Views}
#+END_figure

The verification card (\Fref{fig:shot-verify}) includes the item view from the
list at the top, displaying the same information as in the list view (see
above).  Below this item is a status message, which informs the user of this
Linked Identity's status in a brief text, including the confirmation timestamp
for confirmed and creation timestamp for a user's own identities.  If the Linked
Resource type is /viewable/, i.e., if the wrapped URI is of a type which can be
displayed in a reasonable way by opening it with the regular Android Intent
mechanism, the card includes a "View" button for this purpose.

To start the verification process, the card contains a "Verify" button at the
bottom right, which on click initiates an asynchronous VERIFY operation on the
Linked Resource.  On failure, this operation displays a generic error message in
the card view, and (as is common in OpenKeychain) a "snackbar" notification at
the bottom, which contains a more precise error message and also a button to
display the log created during the verification.  On success
(\Fref{fig:shot-verify-confirmed}), the "Verify" button changes to "Confirm" and
a message is displayed to the user which informs them that the link between the
resource and the key was securely verified, and that they can confirm this
identity if they believe the resource (referred to in a resource-specific way,
i.e., "the account") is genuine.  The information displayed in these steps is
generally obtained from the LinkedVerifyResult object returned by the operation.

# keyspinner

** Implemented Types of Linked Resources
<<sec:ok-linked-impl>>

The prototype implementation of Linked Identities supports four types of Linked
Resources.  The selection of types was made primarily based on demonstrability,
usability, and diversity to cover the scenarios mentioned in
\Fref{sec:example-lids}.  This covers only usability and formatting aspects of
particular resource types, not security (see \Fref{sec:attack-scenarios} for a
discussion of attack scenarios).

It should be mentioned that all resources have their individual technical
advantages and disadvantages, but their actual use and trustworthiness can not
be gauged without taking into account the perception and personal experience of
the individual user.

*** Twitter
<<sec:impl-twitter>>

The Twitter Linked Resource type (see also \Fref{sec:lid-example-twitter}) was
chosen as one of the most relatable resource types available.  Tweets are
well-suited as Linked Token, and the URI structure they are identified by is
easy to understand.

\begin{example}
    \centering
    \vspace{0.2cm}
    \includegraphics[width=0.90\textwidth]{images/uri-twitter}
    \caption{Linked URI to a Twitter Resource}
    \label{ex:luri-github}
\end{example}

This resource also serves as a good example for the recommendation of semantic
understanding of wrapped URIs (see \Fref{sec:linked-id-verify}).  It is possible
to retrieve the tweet by "scraping" the wrapped URI, i.e., retrieving the
contents of the URI and parsing the data from the returned website, making
assumptions on the structure of the returned HTML, or even just matching the raw
text with a regular expression.  This approach is not only prone to failure if
the structure of the retrieved page changes however, it is also insecure because
the page includes not only content controlled by the creator of the Linked
Identity, but also public replies to the tweet.

To avoid these issues, the user handle and tweet ID are parsed from the URI (see
\Fref{ex:luri-github}). The Twitter API[fn:twitter-api] is then used to directly
retrieve the tweet by its ID in a JSON data structure.  As a simple sanity
check, the user handle of the returned tweet object is checked against the one
in the URI.

Another helpful aspect of the Twitter API is the option to retrieve all recent
tweets of a user.  This makes it a simple task to obtain the ID of the newly
posted tweet during creation of a Linked Identity.

*** GitHub

The GitHub resource type (see also \Fref{sec:lid-example-github}) has very
similar properties to the Twitter one, and does not serve to demonstrate any
particular technical details.  It was chosen solely for its reach in the free
and open source open source developer community.

*** DNS Domain Names
<<sec:impl-dns>>

Support for DNS Domain Names (see \Fref{sec:lid-example-dns}) was added as a
type of wrapped URI which uses a different scheme from HTTPS, and also one where
the referenced data payload is not meant for human consumption, making it a good
candidate for use of an alternative token format.  Domain names are not viewable
(see \Fref{sec:impl-verification}) like the other implemented resources, which
reduces the necessary actions by the user to confirm an identity of this type,
but also makes it less relatable.

\begin{example}
    \centering
    \vspace{0.2cm}
    \includegraphics[width=0.70\textwidth]{images/uri-dns}
    \caption{Linked URI to a DNS Resource} \label{ex:uri-dns}
\end{example}

The DNS URI scheme is described in RFC 4501 \cite{rfc4501}.  The supported
subset of this specification consists of a fully qualified domain name (FQDN),
and an optional record type (see \Fref{ex:uri-dns}).  The only supported type of
record is "TXT", which is a generic type available for storing arbitrary string
data, and also the only suitable type currently available.  A TXT record is a
string, the format of which is specified in RFC 1464 \cite{rfc1464}, and is
essentially a simple key-value format delimited by the first occurrence of the
equal sign.  Because DNS records are not in danger of being overlooked as not
meaningful, or easily published by an inexperienced user, we forego the earlier
recommendation that the token text should imply its own meaning in a
human-readable way (\Fref{sec:linked-id-token}). We specify a simple alternative
format for the token in ABNF:

: tokenuri    = "openpgp4fpr" "=" fingerprint
: fingerprint = 40*<HEXDIG>

The DNS querying is performed by the lightweight MiniDNS[fn:minidns] library.
This library does not support DNSSEC at the time of this writing, which is why
the keyserver queries are not secure.  After closer examination of its security
properties, support for this type of resource has been ultimately disabled in
the implementation.  See \Fref{sec:attack-dns} for a more thorough discussion of
this decision.

An interesting future extension to this Linked Resource type could be support
for the OPENPGPKEY record type as introduced in an Internet Draft to use a
method similar to DANE for OpenPGP key propagation \cite{wouters2015dane}.  This
this record type not only refers to an OpenPGP key, but includes a minimized
version of the key data itself, providing a one-way trust link from the domain
name to the key.  Meant primarily for discoverability, the URI scheme which is
used in this manner depends on the e-mail address, and is usually used to look
up the key of an intended recipient.  Adding a Linked Attribute to an OpenPGP
key which is linked to an e-mail address in this manner would change this trust
link from one-way to a mutual one.  This draft is still a work-in-progress,
consequently no ID is assigned so far to the proposed OPENPGPKEY record, which
would be a necessary prerequisite for implementation.

*** Website (TLS)
<<sec:impl-website>>

Websites (see also \Fref{sec:lid-example-website}) were added as a Linked
Resource type which is relatable to people who already link to their OpenPGP key
from their website.  It is also an example for the use of both flags and
parameters.

\begin{example}
    \centering
    \vspace{0.2cm}
    \includegraphics[width=0.85\textwidth]{images/uri-website}
    \caption{Linked URI to a Website Resource}
    \label{ex:lid-website}
\end{example}

This type of Linked URI (see \Fref{ex:lid-website}) is defined by the flag
"generic", and demonstrates how semantic knowledge of the entire URI is
necessary to process it.  The "generic" flag affects the meaning of the Linked
URI in a way which explicitly allows retrieval of the resource by a regular
HTTPS mechanism, accepting the Linked Token anywhere in the retrieved text.
This makes sense for websites which are controlled entirely by the user, like
personal homepages, but does not work in general for social media networks.

The optional "pin" parameter adds the presence of a specific certificate with
the given fingerprint in the certificate chain as an additional requirement for
the VERIFY operation.  This shifts the anchor of the trust chain from any
Certificate Authority to a specific one, or even to one particular certificate,
reducing attack surface and flexibility.

* Evaluation
<<chap:evaluation>>

Linked Identities describe the fairly general concept of authentication via
mutual reference to a resource with previously established trust.  The existing
OpenPGP standard has been stable for a long time for end-to-end encrypted
communication, but is plagued by usability aspects, particularly for
authentication.  This makes it a promising candidate to supplement with
authentication via Linked Identities.  Even in the context of Linked Identities
for OpenPGP, there are different possible approaches, with no clear-cut best
candidate.  The first widely deployed implementation is Keybase (see
\Fref{sec:keybase} for a detailed description), and this thesis introduced and
implemented a second approach based on Linked Attributes.

In this chapter, we evaluate Linked Identities, and more specifically Linked
Attributes, in three ways.  Firstly, we compare Linked Attributes as proposed in
this thesis to the approach of the Keybase platform.  Secondly, we enumerate and
evaluate a number of attack scenarios introduced by the use of Linked
Identities, weighing the advantages and disadvantages of particular resource
types against each other.  Finally, we conduct a user study to evaluate the
perceived usefulness of Linked Identities and usability of the implemented user
interface in OpenKeychain.

** Comparison of Keybase and Linked Attributes

In this section, we highlight and contrast the technical differences between
Keybase and Linked Attributes as introduced in this thesis.

- Linked Identity Data Format :: The data and signature format of the respective
     identity objects differ significantly.

     Keybase uses JSON objects for the Linked Resource reference itself which
     contain a string type specifier plus type-specific parameters.  These
     objects are part of another JSON structure referred to above as Keybase
     objects (see \Fref{sec:keybase-objects}), which contains an OpenPGP
     signature over the Linked Resource JSON object.

     Linked Attributes use URI Attributes which contain a URI of a specific
     Linked URI scheme to encode the reference to the Linked Resource.  URI
     Attributes are certified by the primary key just like other identity
     packets, which allows them to be distributed as part of the OpenPGP key.

     Neither of these data formats has an inherent technical advantage, although
     URI Attributes are arguably more in keeping with the design of OpenPGP as a
     base for the format than JSON objects.

- Linked Identity Authority :: For both implementations, the ultimate authority
     over an OpenPGP key's associated Linked Identities lies with its primary
     key.

     This authority is exerted very directly for Linked Attributes: The User
     Attribute packets are associated to a key by the self certificate issued by
     the primary key itself.  Self-certification of OpenPGP packets is an
     inherent capability of the primary key in an OpenPGP key and can not be
     done by a subkey regardless of capability flags.  This design is quite in
     line with how other types of identities are handled in OpenPGP.

     For Keybase identities, the signature issued over the identity JSON object
     is made by any subkey of the OpenPGP key which has the "sign" key flag,
     which may be the primary key itself or a proper subkey.  This level of
     indirection allows a signing subkey to issue signatures for identity
     management, assuming in this regard the purpose of the primary key.  This
     defeats the separation of concerns otherwise achieved by distributing the
     available key flags over multiple subkeys.

- Linearity of Signatures :: Keybase Objects as well as Linked Attributes are
     totally ordered by timestamp, but have different cryptographic properties.

     In addition to a timestamp, Keybase objects include a hash of the
     previously issued object.  This establishes a linear dependency along all
     objects down to the first one, ensuring that no intermediate objects are
     missing in addition to the total ordering of objects by timestamp.  This is
     a necessary feature for a centralized distribution model, because the
     server would otherwise be in a position to withhold particular signed
     objects or their revocation from a client in a targeted attack.  With this
     feature, it can only withhold most recent objects rather than arbitrary
     ones, and this is further prevented by keeping a log of all objects in a
     Merkle tree (see \Fref{sec:keybase-fork-consistency}).

     Linked Attributes (more specifically, their certificates) include a
     timestamp, but do not cryptographically ensure the ordering or availability
     of all objects.  This is a consequence of the decentralized distribution
     model, although somewhat remedied by the redundancy of the distributed
     storage.  Although this is a feature Linked Attributes are missing compared
     to Keybase objects, it also severely reduces complexity of the mechanisms
     involved in certification and verification, avoiding the requirement of
     additional retrieval of nodes from the Merkle tree during verification.

- Foreign Certifications :: Certifications over the validity of Linked
     Identities are an optional feature users can use to certify the validity of
     identities which are not their own, which is present in both Keybase and
     Linked Attributes.

     For Keybase, this is achieved by the tracking feature, which allows a user
     to sign not only a specific identity, but due to the total ordering and
     linear dependency of Keybase objects (see the previous item), the entire
     state of a Keybase account.  A tracking statement is thus based on a
     snapshot of the Keybase account, rather than on individual identities.

     Linked Attributes use the same mechanism for certification as other types
     of identities in OpenPGP keys, primarily User IDs.  They are then shared
     together with the Linked Attribute they are issued for, and hence with the
     OpenPGP key itself.

     Although these approaches are quite different technically, they are fairly
     equivalent in the way they are used and implemented.

- Distribution :: Keybase uses an out-of-band approach for distribution of
     Linked Identity data, which is made available on a centralized server
     specialized for this purpose only, effectively making it a layer on top of
     OpenPGP which is completely independent.

     Linked Attributes are distributed as part of OpenPGP keys themselves,
     building on existing keyserver infrastructure.

     Infrastructure for Linked Identity distribution is untrusted in both cases,
     which is reasonable since their entire purpose is to facilitate
     authentication directly between keys.  The technical distribution aspect
     mostly affects how tight the binding to OpenPGP key is, and has only
     indirect influence on usability

     Not considering the limited available support in implementations at this
     point in time, Linked Attributes are better integrated with OpenPGP keys
     and not built on open standards, rather than an architecture which is
     controlled by a small group of developers.  The aspects of automatic
     distribution and seamless interoperability may give Linked Attributes an
     edge in adoption not only by the existing user base, but also by developers
     of OpenPGP implementations.

- Verify Operation as Core Mechanism :: Keybase and Linked Attributes both
     include mechanisms for verifying Linked Identities, both of which offer the
     same set of features and implementation details in most regards.  They
     takes a reference to a Linked Resource as input parameter, retrieve the
     resource and see if their input matches.

     The largest difference is in the data stored in the resource: Since the
     Linked Attribute is part of the OpenPGP key itself, a simple reference to
     the key is sufficient for Linked Attribute resources.  For Keybase objects,
     the minimum requirement would be a cryptographically secure reference to
     the Keybase object itself, however the implementation of Keybase elects to
     place the complete signed JSON object and its ASCII-Armored OpenPGP
     signature in the resource.  For size-constrained resources, a hash of the
     signature data is used instead.

- Discoverability :: For authentication methods where communication partners do
     not directly exchange fingerprints, a key discovery method is required to
     obtain key candidates to perform any sort of authentication operations on
     in the first place.

     The centralized architecture and user namespace of Keybase allows for very
     good discoverability properties.  It is possible on the server or through
     the API to search for users by their Keybase name, and also for Linked
     Identities since the server has an understanding of all identity proofs.

     For Linked Attributes, discoverability is a feature which is possible to
     implement, but at this point entirely missing.  Unlike User IDs, User
     Attributes are opaque binary data as far as keyservers are concerned, so
     search even by simple string comparison is not currently available.  This
     is not a critical aspect, and can be implemented relatively easily.  It is
     however not a part of the implementation created for this thesis, and left
     to further work (see \Fref{sec:further-work}).

** Attack Scenarios
<<sec:attack-scenarios>>

To perform a MitM attack on a communication which is secured by OpenPGP, an
attacker needs to trick the sender into using a forged OpenPGP key instead of
the recipient's genuine one.  We evaluate here how the general scenario of
authentication in OpenPGP is affected by the presence of Linked Identities.

Following the design of keyservers (see \Fref{sec:keyservers}), key discovery in
OpenPGP is an obvious point of intrusion for an attacker.  All aspects of a key
besides its fingerprint can be forged, which means an attacker can trivially
create a fake key which has all the same identities as another, and thus shows
up together with the genuine key for any query by identity.  If the user does
not know the fingerprint of the key they are looking for, they have no way at
that point to distinguish a genuine key from a fake one.  For two more advanced
attack scenarios, the attacker can set up a keyserver of their own and make it
part of the pool, or they can intercept the client's connection to the
keyserver.  In both of these cases, the attacker controls the keyserver response
entirely and can return the forged key as the only available one to the
attacker.

Regardless of specific scenario, keyservers are a common means of obtaining an
OpenPGP key, but are by design not authenticated.  This means a user must
perform some sort of authentication on a key before its use in secure
communication, otherwise there is no protection against a MitM attack.  Linked
Identities are one such means of authentication for OpenPGP keys: they provide a
way of immediately authenticating the key, but in so doing add to the attack
surface for incorrect authentication.

The authentication process via Linked Attributes as intended basically requires
success of two steps:

1. The VERIFY operation must succeed.

2. The user must deem the resource genuine upon inspection.

We expect implementations to be compliant with the the standard, which allows us
to make the hard assumption that certifications of Linked Attributes will only
ever be issued after a successful call to the VERIFY operation (see
\Fref{sec:linked-id-verify}).  Implementations are also expected to ask the user
to thoroughly check if the Linked Resource looks genuine to the best of their
knowledge, however this always leaves a margin of human error.

The security of an authentication based on a Linked Attribute depends on both of
the above steps.  If the VERIFY operation can be duped into returning a positive
result when the Linked Token doesn't exist or has a different fingerprint, the
user has little chance to notice this and will likely proceed with certifying
the key.  If the user certifies a Linked Attribute based on the VERIFY operation
alone this provides no authentication either, since Linked Attributes which
correctly verify, but do not actually belong to the expected user, are trivial
to create.

*** Attack Surface of URI Attributes

The content of URI Attributes is technically almost equivalent to that of User
ID packets (see \Fref{sec:uri-attributes-uid}), and adds no special semantics to
signature packets made over it.  Compatibility handling of newly specified User
Attributes is already part of standards compliant implementations, this was
tested at least for the GnuPG and SKS Keyservers versions which are currently
deployed as stable (see \Fref{sec:user-attributes-compat}).  Since support in
these implementations is already mature, there is no reason to assume that the
addition of URI Attributes adds new attack vectors to the OpenPGP data model
itself on either the conceptual or implementation level.

*** Attacker Capabilities

There are two ways an attacker can dupe an application into returning a positive
result on a VERIFY operation, they can either substitute or change the Linked
Token on the site where it is saved, or inject a Linked Token with a different
fingerprint during retrieval.  Both of these are based off the authentication
properties of the communication between the verifying client and the platform
where the data is stored, or the integrity of the platform itself.

Different resource types are resistant or vulnerable to different attackers,
which mandates a more diverse approach than a unified threat model to
investigate their properties.  We define a number of independent capabilities an
attacker may possess.  These capabilities are based off the ends available to an
attacker, the concrete means and technical approach by which these are obtained
are unimportant for this evaluation.

- Intercept arbitrary connections (INT) :: An attacker with this capability is
     able to intercept arbitrary connections of the client, including injection
     or modification of data, and redirection of the connection as a whole.
     This capability is typically available to the operator of the user's
     network, and basic requirement for most attacks.

- DNS Interception (DNS) :: An attacker with the DNS capability is able to spoof
     DNS resolutions made by the client.

     The DNS protocol without extensions provides no authentication or integrity
     of records itself \cite{rfc1034}.  There are also several attacks which
     allow an attacker to spoof responses, even without the INT capability.  See
     \Fref{sec:attack-dns} for a more detailed discussion on DNS security.
     These factors combined make this is a fairly weak capability.

\clearpage

- Issue X.509 certificates (CA1, CA2) :: With this capability, an attacker is
     able to issue X.509 certificates by an acknowledged certificate authority.
     This capability is subdivided into two related ones: The CA1 capability
     allows an attacker to get a certificate signed by some recognized CA for
     any domain.  CA2 allows an attacker to obtain a valid certificate for any
     domain and from any particular CA.

     The entire purpose of the X.509 PKI is to avoid the existence of an
     attacker with this capability.  It is still regarded available for state
     level attackers, who are able to lawfully coerce CAs in their country to
     sign certificates they require \cite{soghoian2012certified}.  According to
     a survey by the EFF \cite{efftlsmap}, the number of CAs is quite large with
     more than 650 entities which work as CAs in the trusted lists of Mozilla
     and Microsoft Windows, many of which lie dormant and have actually signed
     few or no certificates.  This sheer volume of available CAs suggests that
     it is indeed possible for individuals to obtain valid certificates by
     exploiting the policies or software of any valid CA, and concrete
     approaches have been reported by several researchers \cite{certvulnnote}
     \cite{sotirov2009breaking} \cite{marlinspike2009new}
     \cite{dougherty2008cert}.


- Malicious Third Party (MTP) :: If a third party is involved in publishing the
     resource, this third party must be trusted.  There are three ways this
     trust can be breached:

     + Firstly, the platform itself may be malicious.  This attacker model is
       the "ma\-li\-ci\-ous-but-cautious" attacker as defined by Ryan
       \cite{ryan2013enhanced}, where the provider itself may launch active
       attacks, but protects the security of the user from outside attackers.
     + Secondly, the platform may have specific security issues which an
       attacker can exploit, for example to publish data under a name he does
       not control.
     + Lastly, similarly to the attacker model in CA1, a state level attacker
       may lawfully coerce the platform into cooperation.

     Independently of the precise origin, this capability allows an attacker to
     directly alter a Linked Resource as it is retrieved from its site of
     storage, publish one as the genuine account of a user, or even fake the
     presence of the resource for the client connection only.

     Platforms are usually bound by law not to compromise the integrity of their
     platform to the disadvantage to their users, and can also be assumed to
     value their credibility, and invest into the security of their platform to
     make it very difficult for an attacker to gain this capability through a
     software vulnerability.  They may however be bound by law to cooperate with
     authorities.  For these reasons, this is a fairly strong capability which
     is likely to be available to some degree to state level attackers, but not
     so much for individuals.

\clearpage

*** Attacks on the VERIFY Operation

#+BEGIN_LATEX
#+LATEX_HEADER: \newcommand{\isparam}{\textsuperscript{1}}
#+LATEX_HEADER: \newcommand{\isimpl}{\textsuperscript{2}}
#+END_LATEX

# | /                      | <                |                               < |                         |                           |
#+LATEX: \begin{table}
#+LATEX: \caption{Overview of Attack Scenarios and Complexity for Involved Parties}
#+LATEX: \label{tab:attack-comparison}
| Resource Type                          | Sufficient Attacker Capabilities | \rot{Verifier Complexity} | \rot{Implementation Complexity} | \rot{Issuer Complexity} |
|----------------------------------------+----------------------------------+---------------------------+---------------------------------+-------------------------|
| Website (TLS)                          | INT+CA1, DNS+CA1                 |                         2 |                               1 |                       2 |
| Website (TLS) + CA Pinning\isparam{}   | INT+CA2, DNS+CA2                 |                         2 |                               1 |                       2 |
| Website (TLS) + Cert Pinning\isparam{} | -                                |                         2 |                               1 |                       3 |
| Website + Perspective                  | -                                |                         3 |                               2 |                       2 |
|----------------------------------------+----------------------------------+---------------------------+---------------------------------+-------------------------|
| Twitter                                | INT+CA1, DNS+CA1, MTP            |                         1 |                               1 |                       1 |
| Twitter + CA Pinning\isimpl{}          | INT+CA2, DNS+CA2, MTP            |                         1 |                               2 |                       1 |
| Twitter + Cert Pinning\isimpl{}        | MTP                              |                         1 |                               3 |                       1 |
| Twitter + Perspective                  | -                                |                         2 |                               2 |                       1 |
|----------------------------------------+----------------------------------+---------------------------+---------------------------------+-------------------------|
| DNS                                    | INT, DNS, MTP                    |                         3 |                               1 |                       2 |
| DNS + DNSSEC (hosted)                  | MTP                              |                         3 |                               2 |                       2 |
| DNS + DNSSEC (self-operated)           | -                                |                         3 |                               2 |                       4 |
| DNS + Perspective                      | -                                |                         4 |                               2 |                       2 |
#+LATEX: \isparam{} = Parameter \\ \isimpl{} = Implementation Choice
#+LATEX: \end{table}

In this section, we will evaluate the possible attack scenarios on concrete
resource types with specific parameters, flags, and also decisions made for the
implementation of the VERIFY operation.  These distinct scenarios each have
advantages and disadvantages compared to others in terms of security, applicable
threat models, and usability.

Each flag, parameter, and implementation decision yields a different set of
relevant attacker capabilities, and also affects the parties involved in the
VERIFY operation.  For the purpose of comparison in this evaluation, these
effects are generalized as /complexity/ for each involved party.  Complexity is
used here as a very abstract measure of intricacies the party is subjected to.
Scoring is strictly relative to other resource types for the same involved
party.

The involved parties are:
- The Verifier :: The user who performs performs the verification of the Linked
                  Attribute.  This complexity is mostly influenced by how
                  relatable the resource is, and required technical knowledge.
- The Implementation :: The implementation used by the Verifier.  This
     particularly means the VERIFY operation, but may also include other
     aspects.  Implementation complexity may be affected by lines of code,
     required libraries, and maintenance tasks.
- The Issuer :: This is the issuer of the Linked Attribute, who consequently
                also controls the resource.  Complexity for the issuer includes
                technical knowledge, longevity of the Linked Attribute, and
                required maintenance.

\Fref{tab:attack-comparison} gives an overview of all resource types, required
attacker capabilities for a successful attack, and complexity for each party.
Refer to the relevant section for an explanation on each complexity score.

**** Website (TLS)
<<sec:attack-websites>>

For Linked URIs for a Website resource, an attacker with the INT or DNS
capability is able to intercept connections meant for the HTTPS server at any
given domain name.  But, to actually impersonate the server for a TLS-secured
connection, they also require a X.509 certificate accepted as valid for the
domain name by the client.

Spoofing a regular HTTP connection is possible with either of these capabilities
alone, which together with the widespread use of TLS makes unsecured HTTP
websites not a reasonable Linked Resource to use.

The HTTPS resource as implemented comes in three variants: Without pinned
certificate (see \Fref{sec:impl-website}), with a pinned certificate authority,
or with a specific pinned certificate.  The variants offer different trade-offs
between security and maintenance effort on the side of their issuer, but
complexity is small in all cases for both the implementation and the certifying
user, since certificate pinning is simple to implement and the verifying user is
not affected at all by this choice.

The issuer complexity of a Website includes maintenance of a Website and TLS
certificate in the first place, which puts it at a slightly higher relative
complexity than Twitter.  On the other hand, the assumption that a Website is
maintained by the user themselves excludes attack scenarios based on the MTP
capability.  Security aspects are almost entirely up to the issuer of a Linked
Attribute for this resource type, since the use of retrieval methods of all
variants described here is decided upon exclusively by the issuer.

Compared to other resource types, little room for interpretation is left on how
retrieval is implemented, leaving no design decisions up to the implementation,
which results in a low implementation complexity for all variants.  The
verifying user needs to distinguish whether the Website and URI are genuine for
the owner of the key.  Websites are easier to spoof than Twitter accounts, and
lack a notion of following other users, which means verifier complexity is
slightly higher than for Twitter resources.

***** Website (TLS) without Pinning

With no certificate pinning, the authentication of TLS connections relies on a
X.509 certificate signed by any certificate authoritity in the client's list of
valid CAs (see \Fref{sec:x509}), as is the common case for most TLS secured
connections on the internet.  This variant requires its owner to maintain a
HTTPS webserver with a signed X.509 certificate, which is not a trivial
requirement even for a person who already operates their own website.  A signed
certificate usually incurs yearly fees, which few hosters of personal websites
are willing to pay.  The StartSSL CA has started signing certificates free of
cost since February 2005\cite{startssl}, but has to this point remained the only
CA to make this offer.

***** Website (TLS) with CA Pinning

By pinning the certificate to a particular CA, an attacker will need to get a
signed certificate from the particular CA chosen by the owner of the Linked
Identity.  This does not directly increase maintenance costs on the resource, as
long as the owner sticks to the same CA for their certificates.  If the user
does change their CA, they will have to revoke the Linked Identity and re-issue
with an updated pinned certificate, invalidating all signatures made on the
previous one.  This increases the required capabilities of an attacker to CA2,
moving the trade-off only slightly from maintenance towards security.

Since the implementation needs to support TLS for all variants of the Website
resource, the additional check whether the certificate pinned by the parameter
is in the chain of trust adds only negligible implementation complexity.

***** Website (TLS) with Specific Certificate Pinning

Pinning the certificate to the one used by the webserver itself in a Linked
Resource, rather than just that of the signing CA, effectively removes reliance
on the X.509 PKI for authentication from the retrieval mechanism.  By the same
token, this method is suitable for use with certificates which are self-signed
rather than signed by a CA, although a website with such certificate will not be
displayed without a security warning in the browser, which hardly makes this an
attractive option.  A Linked Attribute of this type requires the server to
authenticate with a specific certificate, which means changing the server
certificate also involves replacing the Linked Identity with a new one,
significantly increasing maintenance cost, severely limiting the lifetime of the
Linked Attribute.  On the plus side, this method excludes all possible attack
scenarios which rely on spoofed certificates.

**** Twitter
<<sec:attack-twitter>>

The security of the Twitter resource can be split into two separate aspects:
Transfer security during retrieval, and honesty of the Twitter platform itself.
Compared to the Website resource (see above), the factors of influence on the
security of the VERIFY operation on the Twitter resource lie with the client
implementation, rather than with the issuer or the verifying user.  This
resource is prototypical for social media type resources, and other platforms
can be expected to share most security considerations from this section.

# pull up widow line
\enlargethispage{\baselineskip}

The Twitter API makes data available as JSON encoded objects via a TLS-secured
HTTPS connection (see \Fref{sec:impl-twitter}).  As above, an attacker with the
DNS or INT capability can intercept this connection, in which case the transfer
security relies on the security of TLS, i.e., on the X.509 PKI.

The second aspect is about the sincerity of Twitter itself as a distribution
platform.  One quality of all social media and "cloud" type resources where a
third party is directly involved in the distribution of the resource is that
their security relies - besides transfer security aspects - on the candor of the
platform itself.  An attacker with the MTP capability for a given platform can
publish a resource under the name of the user, or possibly serve altered content
to the verifying user in a targeted way.  By this method, an attacker can bypass
transfer security entirely, rendering counter-measures like certificate pinning
ineffective.

***** Twitter without Pinning

For an implementation which does not use pinning, i.e., accepts any CA
certificate, the transfer security can be overcome by an attacker with CA1
capability.

***** Twitter with CA Pinning

The Twitter API documentation recommends use of the "Symantec Class 3 Secure
Server CA - G4" root certificate as a pinned certificate for the
=api.twitter.com= domain \cite{twitterapissl}, however during implementation it
was found that the domain actually signed by the "VeriSign Class 3 Secure Server
CA - G3" root certificate, an observation which can be assumed to be an error in
documentation.

Pinning the correct CA root certificate increases the required attacker
capability to CA2.  Differently from the Website resource (see above), this
increases complexity for the implementation rather than the issuer of the Linked
Attribute.  The added complexity is of the same type, but affects the deployment
of the implementation: Stronger pinning yields stronger security assertions, but
requires an update of the software should the pinned certificate change at any
point.  Depending on the distribution scheme of the implementation, deployment
of a new version when the particular =api.twitter.com= certificate changes can
be a big problem.  The discrepancy between the root certificate suggested by the
Twitter API documentation and the root certificate which is actually used
emphasizes this problem and reinforces that the transient nature of pinned
certificates should be taken into account by implementation design
considerations.

***** Twitter with Specific Certificate Pinning

Foregoing the recommendation from the Twitter API documentation to pin the CA
root certificate, it is also an option for the implementation to pin the
particular certificate used by =api.twitter.com=, which excludes the possibility
of intercepted connections in the given threat model.  This option makes the
same trade-off as pinning the CA certificate, meaning it increases both security
and implementation complexity even further.

**** DNS
<<sec:attack-dns>>

The DNS Linked Resource identifies a DNS domain name, but leaves retrieval of
the record data almost entirely up to the VERIFY implementation.  The DNS
resource type is special in that domain names are not viewable (see
\Fref{sec:impl-verification}) and records are not human readable.  This means
the verifying user needs to be able to discern the trustworthiness of a domain
name from its name alone.  The resulting complexity for the verifying user is
higher than for the Website resource, which contains more information and is
more relatable.

The DNS protocol in its original form does not include facilities to ensure
integrity or authentication of response data \cite{rfc1034}, which makes use of
this protocol without security extensions very vulnerable.  An attacker with the
INT capability can trivially fake responses to DNS queries in a MitM attack, but
even a weaker attacker who is unable to modify packets can spoof responses with
relative ease \cite{bau2010security}.  There are also more advanced Out-of-Path
attacks, most well-known the Kaminsky attack \cite{kaminsky2008black}, which
combines injects delegation responses, delegating the authority over targeted
zones to themselves.  A good overview of DNS threat models is the analysis by
Atkins and Austein \cite{rfc3833}, which was used as a basis for the design of
the DNSSEC extensions.

The DNS resource can be used with or without DNSSEC, and can be hosted or
self-operated for either of those cases.

***** DNS without DNSSEC
<<sec:attack-dns-bare>>

The issuer of a DNS Linked Attribute needs to manually publish a TXT record for
their domain.  For domain owners who do not operate their own DNS server, many
registrars provide a "dns hosting" service, which lets the registrar provide the
authoritative DNS server, allowing the domain owner to easily manage DNS records
via a web interface.  The technical knowledge required for this operation from
the user is comparable to publishing data on a Website they operate, placing the
resources at equal complexity.

It is also possible for the issuer to operate a own domain name server of their
own, rather than relying on dns hosting.  Without use of DNSSEC however, this
has no influence on the DNS security properties, while increasing issuer
complexity.

Resolving DNS names is a feature of the network stack in all operating systems,
which makes implementation of this resource type (without DNSSEC support) very
easy.

Since the domain registrar controls delegation of the authoritative name server,
the DNS resource without DNSSEC is vulnerable to an attacker with the MTP
capability, in addition to DNS and INT.  This leaves the DNS resource extremely
vulnerable.  Following these considerations, this type of resource has been
ultimately disabled in the implementation created for this thesis, which did not
offer support for DNSSEC (cf. \Fref{sec:impl-dns}).

***** DNS with DNSSEC

DNSSEC extends DNS with a public-key infrastructure, providing compatible client
resolvers with cryptographic assurance of the integrity and authenticity of DNS
records, even in the presence of an active network attacker \cite{rfc2535}.  The
details of the DNSSEC protocol are complex and out of scope for this document;
As a rough overview, authoritative name servers which support DNSSEC generate a
public and secret key pair for each zone, which they use to create signatures
over DNS records of their zone.  The public key must be signed by the delegating
name server, forming a chain of trust up to the root zone.  See
\cite{kolkman2009dnssec} for a comprehensive and more complete overview.  Since
DNSSEC authenticates retrieved record data, its use prevents both the INT and
DNS attack scenarios.

The increase in complexity for an implementation to support DNSSEC is relatively
mild, since libraries which encapsulate the functionality are available for most
platforms \cite{dnssec-libraries}.

The increase in complexity for the issuer depends on whether they use dns
hosting to manage their domain name, or operate their own server.  For hosted
dns, if the provider supports signing DNS records on their own, the technical
difficulty for the user does not increase.  However, this feature is offered as
a complimentary service only very scarcely \cite{dnssec-binero}, but is found in
premium dns hosting providers \cite{dnssec-dyn} or incurring additional fees
\cite{dnssec-godaddy}.  As a further drawback, DNSSEC with a hosted DNS provider
is still vulnerable against an attacker with the MTP capability.

DNS Linked Resource whose issuer operates their own DNSSEC-enabled domain name
server is protected against all attacker capabilities considered here.  The
major disadvantage of this variant of the DNS resource is that the level of
technical knowledge required is higher than any other resource or variant
considered in this evaluation, making this variant available only to expert
users.

***** DNS with Whois

If made available by the domain owner, the whois protocol\cite{rfc3912} could in
theory be used to retrieve contact information about the owner, in place of a
proper "view" of the resource.  However, the format of data retrieved in this
way is human readable plain text, which does not follow a formal nor de facto
standard, and varies widely in practice.  This makes it impossible to reliably
extract specific information like the name of the domain owner.  There is
furthermore significant misuse of the personal data published via
whois\cite{leontiadis2014empirically}, which disincentivizes the use of actual
personal data in such records.

In the way of transfer security, the whois protocol lacks mechanisms to ensure
authenticity, confidentiality, or even integrity of transmitted data (see
section "Security Considerations" in \cite{rfc3912}), allowing an attacker with
the INT capability to trivially alter the information during retrieval.

In conclusion, information obtained by the whois protocol is not only highly
unreliable, but also very easy to spoof for an attacker.  For these reasons, the
whois protocol does not provide a useful source of information for
authentication purposes.

**** Perspectives

The security of all resource types can be strengthened by the use of foreign
certificates as perspectives, as described in \Fref{sec:lid-perspectives}.
Displaying certificates made by authenticated keys to the user as auxiliary
information adds some complexity for both the implementation and the verifier,
but does not affect the issuer.

As an effective counter-measure against all attack scenarios described above, an
implementation or user may apply a policy to certify exclusively Linked
Attributes which were already certified by some other key.  Only a relatively
small amount of trust is required for this key, specifically just enough that
the key is not maliciously supporting the attacker in their attempt to deceive
the VERIFY operation.  A policy like this sacrifices availability for security,
since newly created Linked Attributes may not yet have been certified by a known
key.

*** User Oversights

The VERIFY operation on its own checks the assertion that the Linked Attribute
and Linked Resource are correctly and verifiably associated to each other.  In
terms of authentication, this links the confidence in the authenticity of the
key to the confidence in the authenticity of the Linked Resource.  If the user
has reason to believe the Linked Resource is genuine, usually if they are able
to identify its context to be controlled by the user, this completes the use of
Linked Attributes as a means of authentication.

This also implies that the VERIFY operation on its own does not provide proper
authentication.  If the Linked Resource is valid in the sense of the VERIFY
operation, but points to a spoofed Linked Resource, this may be used to fool the
user into certifying a fake key.  Consequently, an implementation must be
careful to provide the user with enough guidance to not certify Linked
Attributes without performing a manual check of the resource's sincerity. This
is also shown in the user study performed later on (see
\Fref{sec:study-discussion}).

**** Homograph Attacks

A particularly important attack scenario which targets the user is the homograph
attack, described by Gabrilovich in 2002 \cite{gabrilovich2002homograph}.  A
/homograph/ is a character which is difficult or impossible to distinguish from
some other character (those two characters are then a pair of homographs).  For
a simple case, a 0 (the digit zero) is difficult to distinguish from an O (the
capital letter "o"), similarly with an I (capital letter "i") and an l (lower
case "L").  This problem has become an issue for domain names since the
introduction of /International Domain Names/ (IDN) \cite{rfc5891}, which allows
the use of arbitrary unicode characters in domain names.  As an example,
Gabrilovich used the domain "microsoft.com" with a cyrillic "c" and "o"
character, which are are in many fonts virtually indistinguishable from the
characters one might expect.

This problem is less severe in resources where the related names have a
restricted character set, for instance, account handles on Twitter allow the use
of alphanumeric characters in addition to underscores exclusively
\cite{twittercharset}.  Even then, an implementation should make sure to display
the relevant strings in a font where each character is clearly distinguishable.
For resources which support the full set of unicode characters, like domain
names or websites, an implementation may choose to restrict the set of
acceptable characters to the ASCII set or similar.  As a less restrictive
option, the Unicode Consortium published a rather long list of homographs in
unicode \cite{homographsunicode}, which may be used as a basis for restricted
characters.

** User Study

# see userstudy.org

To evaluate the concept of Linked Attributes and the implementation created as
part of this thesis, we conducted a user study.

*** Study Setup

Participants in the study were provided with printed instructions in German (see
Appendix \ref{appendix:handout}), and an LG Nexus 5 Android mobile device, which
came with an unmodified Android 5 "Lollipop" stock ROM, and three preinstalled
applications:

- OpenKeychain :: The OpenKeychain app was installed in a version which included
                  the implementation of Linked Attributes created for this
                  thesis.  The application was set up with a secret key for the
                  name "Alice Skywalker", which participants were instructed to
                  use as their own.

- The Twitter App :: This app was used for interaction with the Twitter social
     network, and was logged in with the account =@AlicSkywalker=.  This account
     had not published any tweets, but followed six accounts, the only relevant
     one being =@Bob3275= in task 4 (\Fref{sec:study-task4}).

- PushBullet :: This app which allows simple sending and receiving of messages,
                called /pushes/.  The app exclusively uses the /share/ operation
                for communication with other processes, as is intended by the
                Android framework.  This app was chosen for its simple
                interface, and is used to both as a sink for messages created by
                the participant (tasks 2 and 4), and to provide data (task 3).

Participants were informed that connectivity problems, and general usability
problems with the Android operating system were not a part of this study.  The
time it took each participant to complete each task was recorded, but not part
of the evaluation.

After the introduction and each task, the participants were asked to gauge
different questions on a five-level Likert scale \cite{likert1932technique},
where 1 is "strong agreement", and 5 is "strong disagreement" with the Likert
item in question.  See Appendix \ref{appendix:likert} for a summary of all
Likert items.

**** Introduction

Before the first task, the printed instructions provided participants with a
brief introduction to the general concept of OpenPGP, and also a description of
Linked Identities.

**** Task 1
<<sec:study-task1>>

For the first task, the participant is asked to sign a text using the predefined
secret key, share it via PushBullet, then verify that the signature is indeed
correct.

This was a preliminary task, which had no connection to Linked Attributes.  It
served the sole purpose of familiarizing the user with the interface of
OpenKeychain, specifically the signing and verification of messages.  For this
reason, the task was divided into 8 small steps, and provided the user with
relatively detailed instructions.

**** Task 2
<<sec:study-task2>>

The second task guides the participant to the Linked Identity creation wizard,
then asks them to follow the instructions on screen to create a Linked Attribute
using a Twitter Linked Resource for the account =@AlicSkywalker=.  As a last
step, they are asked to make sure the Linked Attribute shows up in the key, and
verifies correctly.

This task fulfills two purposes: Firstly, it evaluates if users can successfully
create a Linked Attribute following the interface of the wizard.  Secondly, it
familiarizes the participant with verification of Linked Identities.

**** Task 3
<<sec:study-task3>>

In the third task, participants are instructed to navigate to the PushBullet
app, and from there open a push with OpenKeychain.  The text is encrypted to the
available secret key, and also signed by a key which is not yet available in the
list of keys in OpenKeychain.  The user is asked to decide whether this key is
genuine or not, making use of Linked Identities.

The descriptions of this task are relatively high-level, leaving the user with
instructions and user interface flow of OpenKeychain during the actual
verification.  The interface which shows the decrypted text provides a prominent
"lookup" button to download the unknown key.  After the key has been downloaded,
the button is changed to "show key" one which opens a detailed view of the key,
which includes a list of Linked Identities.

For authenticity of the scenario, the OpenPGP key used to sign the message was
not fabricated for the user study, but the personal one of this author.  At the
time the test was performed, it included two Linked Attributes, one to a GitHub
account and one to a Twitter account, both of which were genuine and verified
correctly.

**** Task 4
<<sec:study-task4>>

The fourth and last task asks the user to find a key for the e-mail address on
the keyservers, confirm it is genuine using Linked Identities, then encrypt a
message to it and send it via PushBullet.

Two keys had been placed on the keyservers for this test.  Both of these keys
contained exactly one User ID which matched the e-mail address, and both
contained a Linked Identity which connected them to a Twitter account.  The
Twitter account from one of the keys was genuine, the other was forged to look
similar.  The accounts could however be distinguished by the following aspects:
- The handles of both accounts are the same as the e-mail address, which ends in
  a four digit number, with a slight variation in the fake account name.  The
  genuine account ends in 3275, which is also found in the e-mail address, the
  fake account ends in 3276.
- The number of accounts followed and following the fake account is zero.  This
  is a clear indication of an account which has been set up recently and is not
  actually used for social interaction.
- The genuine account follows and is followed by the account =@AlicSkywalker=,
  which is the one the Twitter app is logged in with and the participant was
  instructed to use as their own for this test.

The signing and sending part of this task was near identical to the process
performed in task 1.  As instructions provided in task 1 were very detailed,
users were expected to have little trouble following through with this part of
the task.  This way of trivializing this part of the task allowed the user to
focus on the decision of whether they send a message at all: the instructions
specifically say to send an encrypted message "if" the participant could
convince themselves that the key they had imported was genuine.

After finishing this task, participants were asked to gauge in three questions
whether they were able to successfully find and import a key for the e-mail
address, reliably determine whether the imported key was genuine, and if the key
they ended up using was genuine.

*** Study Results

The study was conducted with 11 participants, each in an individual session.
The sessions took 20 minutes and 20 seconds on average, with a standard
deviation of roughly 6 minutes, with no statistically significant outliers.  See
\Fref{tab:user-study-results} for an overview of the success of participants in
individual tasks, and responses to the Likert items.  Participants are numbered
for reference as P01 through P11, in no particular order.

There were no technical issues throughout all sessions, except for two instances
of problems with connectivity due to bad Wireless LAN signal, and one error in
study setup which came up during task 2 for participant P01.  This error was
easily repaired, and did not obstruct the participant in performing the tasks in
a major way.

**** Introduction

According to responses participants gave to the Likert items, only four (P05,
P08, P09, P10) had never used OpenPGP before, the rest were already familiar
with it prior to the test.  All participants were confident they had understood
OpenPGP and Linked Identities after the brief introduction, except for one (P08)
who was only moderately confident.  Five participants had used Twitter before or
were familiar with it (P01, P02, P03, P06, P09), only one did not know Twitter
at all (P10), the remaining participants were at least moderately familiar with
it.  All except one participant (P06) were also familiar with the Android
operating system.

**** Task 1

All participants were able to successfully sign the message, verify the
signature afterwards, and were unanimously confident that they performed both
tasks correctly.  Since the purpose of this task was to get the participant
accustomed to the use of OpenKeychain and PushBullet, and due to the very
detailed instructions provided to the user, this was the expected result.

Six participants were confused in this task with the Android share menu, which
placed the "Decrypt with OpenKeychain" menu item at the top, rather than in the
list.  To remove this aspect of Android usability from the study results, those
participants were given a hint when they could not find the item for a long time
or voiced confusion.

**** Task 2

In the second task, all participants were able to successfully create the Linked
Identity as intended.  Only three participants (P01, P02, P11) subsequently
performed a verification, although all participants except one (P06) stated that
they could successfully verify it.  Five participants (P04, P06, P08, P09, P10)
didn't consider the items in the list of Linked Identities clickable during this
task, the remaining three considered the verification they performed during the
creation of the Linked Attribute sufficient.  Three participants (P05, P07, P08)
wondered whether they actually needed to tweet a message as a part of this
study, but recognized they did when the resource verification resulted in an
error without the tweet posted previously.  Three participants (P06, P08, P09)
misspelled the name of the Twitter account in the second step of the wizard,
which yielded "Resource not found!" errors during the verification step.  All of
them recovered from this mistake on their own.  Two (P06, P08) commented the
error message could have been more helpful hinting a spelling error, and two
(P06, P09) stated that this mistake would probably not have happened for their
own account name.

**** Task 3

Eight participants performed the verify operation, and all who did also
certified the identity.  However, three participants (P01, P05, P10) did so
without viewing the Linked Resource.

The three participants who did not perform the verify operation were all from
the group who did not consider Linked Identity items clickable in the previous
task.  Two of them (P04, P08) did not recover from this and consequently did not
perform any verification.  One of them (P08) stated during the test that the key
would probably be reliable if they knew the name of the Twitter account, and had
some confidence that they key was reliable, the other (P04) did not ultimately
consider the key genuine.  The third participant (P06) did click the menu item,
but decided against clicking the verify button.  This participant later stated
that they felt in an active role for this operation, and since they had no
evidence for the trustworthiness of the identity didn't want to "verify" it.

**** Task 4

# - succesful import
# - three groups
  # + sent correctly (P01, P03, P06, P08, P09, P11)
  # + confirmed but not sent and aware (P02, P05)
  # + sent incorrectly and aware (P04, P07)
  # + sent incorrect but unaware (P10)

In task 4, all participants were able to successfully import both the genuine
and the fake key from the keyserver.  After that, participants had mixed success
fulfilling the task, falling into three groups: Six participants correctly
identified the genuine key.  Four participants (P02, P04, P05, P07) were unable
to distinguish the genuine key from the fake one for different reasons, but were
aware of this.  One participant (P10) got confused entirely, and ended up
sending the message in plain text.

# - P03: did not confirm, but deleted fake key
# - P08: did not verify or confirm, but noticed wrong name and deleted
  # fake key, confident it was the right one

All of the six participants who were able to identify the genuine key, also sent
the message to the correct key.  Two of them (P03, P08) did not confirm the
genuine key but deleted the fake one instead.  All of them based their decision
on the different number in the name of the Twitter account compared to the
e-mail address.  As a special case, one participant (P08), who had also missed
that items were clickable in earlier tasks as well, found the genuine key
without actually performing the verify operation, and based their decision
solely on the name in the list view.

Four participants were unable to distinguish the correct key from the fake one
after examining the Linked Resource, but were aware of this situation.  Two
participants (P04, P07) of this group did not certify either key.  Despite this,
they both sent a message to one of the keys chosen at random, answering
afterwards that they did not trust the key when they sent it.  When asked about
this decision, both said they hadn't considered the task to be optional, so they
rather sent it to a key without confirmation than not at all.  The other two
(P02, P05) certified both keys, but noticed their error afterwards and did not
send a message to either key.  In all four cases, the participants answered in
the Likert items that they did not find a trustworthy key.

# - P02: examined both accounts but didn't find a way to decide on the
  # right one. confirmed both, but decided to trust none.
# - P05: examined both accounts, did not view but confirmed both.
  # noticed mistake afterwards, asked undo

# - P04: checked list of followers, confirmed and sent, but no
  # confidence. later stated because he didn't know the account.
# - P07: did not trust either key after examination and didn't confirm,

Only one participant (P10) failed to identify the genuine key without being
aware of it, and ended up certifying both keys.  They encrypted the message to
one of the keys chosen at random, but did not follow through with the share
action after clicking the button.  Considering the message encrypted at that
point, they subsequently sent the message directly in the PushBullet app as
plaintext.  Only after the plaintext was displayed in the list of pushes did the
participant realize they sent the message without encryption.

# - P10: entirely confused.  both keys certified without view, sceptical
  # about correctness, sent text without encryption, but confidence
  # having found the correct key

An additional observation could be made, which does not affect Linked Attributes
but OpenKeychain directly: After importing new keys in this task, a snackbar
message pops up at the bottom of the screen, which notifies the user of the
result of the operation, and offers a "detail" button.  This button leads to a
display of messages logged during the operation, and is not used as part of an
import user interface flow, unless an error happens during import.  Five
participants (P02, P05, P06, P07, P09) clicked this detail button after they
imported the keys, expecting it to lead to the list of newly imported keys, and
went back to the key list only afterwards.

**** Discussion
<<sec:study-discussion>>

In six cases, participants were able to successfully authenticate a correct key
even in the presence of a fake.  Four other cases decided not to trust either
key.  Assuming that the two participants who sent a message to a key they did
not trust would not have done so had it not been for the study instructions (see
previous section), the decision not to trust a key can still be seen as an
outcome which is not detrimental to the security of the user.  Since Linked
Attributes are meant as an alternative or even complementary means of
authentication, the decision not to trust a key from its Linked Identities alone
leaves the user in the same situation they would have been without the presence
of Linked Identities.  Only one participant (P10) made a decision which actually
resulted in a negative impact on their security properties.  Considering this
participant ended up sending the message in plain text rather than encrypted to
any key, this can arguably be attributed to overall usability properties of
OpenKeychain, rather than those of Linked Attributes specifically.

Looking at the overall turnout of the user study, the implementation of Linked
Attributes created for this study can be cautiously described as a success.  The
problems participants experienced during the study were never of a technical
nature, but related exclusively to the design of the user interface of Linked
Attributes, or sometimes OpenKeychain in general.  Following the observations
made in the study, a number of pain points have been identified where the user
interface needs improvement, which should enhance the overall user experience.

The user study as conducted was limited by the small number of participants, and
the restricted realism of the provided scenario.  The primary use of Linked
Attributes is to make use of the user's prior knowledge of another's profiles in
social media or otherwise controlled resources on the internet.  Since a social
environment is difficult to emulate, the achievable measure of realism in a user
study is fairly limited.

**** Consequential Improvements

The results of the user study highlight some aspects of the user interface which
leave room for improvement.  Due to time constraints, the enhancements listed
here are not a part of the final implementation created for this study.

- When navigating to the detailed view of a Linked Attribute, the actual
  verification operation on the Linked Resource needed to be triggered
  explicitly by the user.  This was commented by two participants (P01, P11) as
  an unnecessary step, and also prevented one participant (P06) from verifying
  the identity in task 3 because the label "verify" conveyed an action of
  consequence to them.  This could be improved by executing the verify operation
  when an identity is clicked, displaying its result as part of the initial
  information, rather than in an extra step.

- After verification, the user interface gave the user the option to immediately
  certify the Linked Attribute.  While this may be a legitimate use case, e.g.,
  if the user recognizes a Twitter resource by its handle, it also leads to an
  increased attack surface if users either don't recognize the importance of the
  manual check of the Linked Resource, or choose to skip the step in a simple
  bout of laziness.

- For the particular use case of the Twitter resource, it turns out the Twitter
  app is less than forthcoming with the relevant information.  The activity
  which shows a tweet displays no information about the account it was posted
  from, and only two participants ever looked at the details page of the account
  they were verifying, rather than only the tweet.  As a simple improvement, an
  option to directly view the Twitter account, rather than the tweet, could be
  offered to the user.

  For a more complex solution, it is also possible to retrieve and display
  public information about the account, like its creation date, number of
  tweets, and number of followers.  This information can be faked with some
  effort though, which may lead to a false sense of security in cases where it
  is.  If the user supplies the implementation with an access token to retrieve
  account-related information from the Twitter API, it would also be possible to
  display whether the user already follows the account referred to in the Linked
  Identity.

- Three participants certified the key, but noticed their mistake afterwards.
  At the moment, this action cannot be undone in the interface, as would be
  possible either by deleting the certificate if it's not uploaded to the
  keyservers (as was the case during this study), or revoking it if it is.
  Since the revocation of certificates for any type of identity is not currently
  supported in OpenKeychain, this feature was not implemented, and is at this
  point left to further work.

- Two participants (P01, P04) stated that they felt unsure during task 1 why the
  input of the key's passphrase was required.  The passphrase input dialog does
  not include a message which describes the particular action the passphrase is
  required for, which is a feature that could be implemented relatively easily.

* Conclusion
<<chap:conclusion>>

In this master thesis, the concept of Linked Identities was introduced for
establishing authentication of OpenPGP keys by linking them with a resource on
the internet by mutual proof of control.

The concept of Linked Identities was first derived as a generalization of the
feature set of the Keybase platform.  From this concept, two Internet Drafts
were written to standardize Linked Identities directly as an extension of
OpenPGP.  The first draft describes a URI scheme which encodes a claim of
control over a resource, together with a format for a token to be placed at the
referenced site for proof.  The second introduces a new type of User Attribute
to the OpenPGP binary packet structure.

As a conceptual evaluation, Linked Attributes have also been contrasted to the
Keybase implementation in terms of technical differences and their implications
on usability.  As a second part of the evaluation, the potential attack surface
of several types of Linked Resource have been examined, providing an overview of
complexities for the issuer, and the verifying user and implementation, and
capabilities which are able to subvert particular types of resources.  The
proposed standards for Linked Attributes were implemented in the OpenKeychain
OpenPGP implementation for Android in a working version, and consequently
evaluated in a user study.  This user study attested the stability of the
implementation, and showed somewhat promising results for the usability and
reliability of Linked Attributes as a complementary means of authentication in
OpenPGP, while also highlighting a number of issues in the user interface
design.

** Further Work
<<sec:further-work>>

The implementation created for this thesis has been shown to introduce no
problems with interoperability (\Fref{sec:user-attributes-compat}), and as we
showed in a user study, appears stable and usable enough for use by consumers.
There are a number of ways to go from here to improve usability, security and
reach of Linked Attributes:

- The most obvious, and probably most important improvement is support for more
  platforms.  OpenKeychain is a native Android application, which means the
  feature is at the moment restricted to the Android platform.  To increase
  reach of Linked Attributes, implementation efforts should focus on support in
  an implementation for a desktop operating system.  Although listed under
  "Esoteric Options", GnuPG already has support for retrieving the content of
  User Attribute packets \cite{gnupgmanesoteric}, which allows implementation in
  any GnuPG-based implementation, or as a stand-alone wrapper application.

- URI Attributes are at the moment treated as opaque content by keyservers
  (\Fref{sec:sks-compat}), and particularly do not offer a search over their
  content, which severely hinders discoverability. Even without semantic
  understanding of Linked URIs, support for text search over URI Attributes
  could be used to find OpenPGP keys by the Linked Identities they contain.

- Following keyserver support for search over URI Attributes, a long term goal
  for keyservers could be to semantically display Linked Attributes, or even
  verify their status.  Compared to a simple search over URI Attributes however,
  especially the latter of these features is a fairly large task.

- The DNS resource has been disabled in the final implementation because of
  security considerations (\Fref{sec:attack-dns-bare}).  To use DNS resources
  securely, an implementation is required which is aware of DNSSEC.

- The use of certificates by already known keys as perspectives (see
  \Fref{sec:lid-perspectives}) has also not been implemented.  This feature
  could be used to provide the user with additional information during
  verification, significantly reducing the attack surface for all resource
  types, with a mechanism OpenPGP are already familiar with.

#+BEGIN_LATEX

\clearpage
\appendix
\printbibliography[heading=bibnumbered]

#+END_LATEX

* Appendix                                                           :prelim:
** URI Attributes for OpenPGP
<<appendix:uri-attributes>>

#+LATEX: \includepdf[pages=-,scale=0.8]{draft-vb-openpgp-uri-attribute-01.pdf}

** Linked Identites for OpenPGP
<<appendix:linked-ids>>

#+LATEX: \includepdf[pages=-,scale=0.8]{draft-vb-openpgp-linked-ids-02.pdf}

** User Study

*** Likert Items
<<appendix:likert>>

****** Introduction

- 0.1 :: I understood the concept of OpenPGP.
- 0.2 :: I was already familiar with OpenPGP.
- 0.3 :: I understood the idea of Linked Identities.
- 0.4 :: I am familiar with the general use of Android.
- 0.5 :: I am familiar with the general use of Twitter.

****** Task 1

- 1.1 :: I was able to successfully sign the text.
- 1.2 :: I was able to successfully verify the signed text.

****** Task 2

- 2.1 :: I was able to successfully create a Linked Identity.
- 2.2 :: I was able to successfully verify the Linked Identity.

****** Task 3

- 3.1 :: I was able to decrypt and read the text.
- 3.2 :: I was able to reliably determine whether the key which signed the
         message was genuine or not.
- 3.3 :: The signing key was genuine.

****** Task 4

- 4.1 :: I was able to find and import a key for the e-mail address.
- 4.2 :: I was able to reliably determine whether the imported key was genuine
         or not.
- 4.3 :: The imported key was genuine.

*** Results Table

#+BEGIN_LATEX
  \usetikzlibrary{trees,shapes.geometric,shapes.symbols,chains,calc,positioning,arrows,decorations.pathmorphing,decorations.pathreplacing}

  \newlength\bubblesize
  \setlength{\bubblesize}{0.6ex}
  \newcommand\yes{
    \begin{tikzpicture}[baseline=0, line width=0.2ex]
      \path[use as bounding box]  (\bubblesize,\bubblesize) circle (\bubblesize-.5\pgflinewidth);
      \fill[black] (\bubblesize,\bubblesize) circle (\bubblesize);
    \end{tikzpicture}
  }
  \newcommand\nos{
    \begin{tikzpicture}[baseline=0.1ex, line width=0.2ex]
      \path[use as bounding box]  (\bubblesize,\bubblesize) circle (\bubblesize-.5\pgflinewidth);
      \draw[black, line width=0.2ex] (\bubblesize,\bubblesize) circle (\bubblesize-.5\pgflinewidth);
    \end{tikzpicture}
  }
  \newcommand\err{
    \begin{tikzpicture}[baseline=0.1ex, line width=0.2ex]
      \path[use as bounding box]  (\bubblesize,\bubblesize) circle (\bubblesize-.5\pgflinewidth);
      \draw[red, line width=0.2ex] (\bubblesize,\bubblesize) circle (\bubblesize-.5\pgflinewidth);
      \draw[red, line width=0.4ex] (0,0) -- (2\bubblesize,2\bubblesize);
    \end{tikzpicture}
  }
  \newcommand\meh{%
    \begin{tikzpicture}[baseline=0.1ex, line width=0.2ex]%
      \path[use as bounding box]  (\bubblesize,\bubblesize) circle (\bubblesize-.5\pgflinewidth);%
      \draw[clip]  (\bubblesize,\bubblesize) circle (\bubblesize-.5\pgflinewidth);%
      \fill[black] (\bubblesize, 2\bubblesize) rectangle (0,0);%
    \end{tikzpicture}%
  }
#+END_LATEX

#+LATEX: \begin{sidewaystable}
#+LATEX: \caption{User Study Results}
#+LATEX: \label{tab:user-study-results}
|     | \multicolumn{1}{c}{Task 0} | Task 1 | \rot{Signed Message} | \rot{Verified Message} | Task 2 | \rot{Created Identity} | \rot{Verified Identity} | Task 3 | \rot{Verified Resource} | \rot{Viewed Resource} | \rot{Certified Key} | Task 4 | \rot{Imported Key} | \rot{Verified Resource} | \rot{Viewed Resource} | \rot{Certified Identity} | \rot{Sent Message} |
| /   | <c>                        | <c>    | <c>                  | <c>                    | <c>    | <c>                    | <c>                     | <c>    | <c>                     | <c>                   | <c>                 | <c>    | <c>                | <c>                     | <c>                   | <c>                      | <c>                |
| /   |                            | <      |                      |                        | <      |                        |                         | <      |                         |                       |                     | <      |                    |                         |                       |                          |                    |
| P01 | 1 1 1 3 1                  | 1 1    | \yes                 | \yes                   | 1 2    | \yes                   | \yes                    | 1 1 1  | \yes                    | \nos                  | \yes                | 1 2 1  | \yes               | \yes                    | \yes                  | \yes                     | \yes               |
| P02 | 1 1 1 1 1                  | 1 1    | \yes                 | \yes                   | 1 1    | \yes                   | \yes                    | 1 1 1  | \yes                    | \yes                  | \yes                | 1 5 5  | \yes               | \yes                    | \yes                  | \err                     | \nos               |
| P03 | 1 1 1 1 1                  | 1 1    | \yes                 | \yes                   | 1 1    | \yes                   | \nos                    | 1 1 1  | \yes                    | \yes                  | \meh                | 1 1 1  | \yes               | \yes                    | \yes                  | \nos                     | \meh               |
| P04 | 1 1 2 3 2                  | 1 1    | \yes                 | \yes                   | 1 1    | \yes                   | \nos                    | 1 2 4  | \nos                    | \nos                  | \nos                | 1 4 4  | \yes               | \yes                    | \yes                  | \err                     | \err               |
| P05 | 2 5 1 2 3                  | 1 1    | \yes                 | \yes                   | 1 1    | \yes                   | \nos                    | 1 1 5  | \yes                    | \nos                  | \yes                | 1 4 1  | \yes               | \yes                    | \yes                  | \err                     | \nos               |
| P06 | 1 1 1 5 1                  | 1 1    | \yes                 | \yes                   | 1 4    | \yes                   | \nos                    | 1 5 -  | \nos                    | \nos                  | \nos                | 1 1 1  | \yes               | \yes                    | \yes                  | \yes                     | \yes               |
| P07 | 1 1 2 2 3                  | 1 1    | \yes                 | \yes                   | 2 1    | \yes                   | \nos                    | 1 1 1  | \yes                    | \yes                  | \yes                | 1 1 5  | \yes               | \yes                    | \yes                  | \nos                     | \err               |
| P08 | 3 5 3 1 2                  | 1 1    | \yes                 | \yes                   | 2 2    | \yes                   | \nos                    | 1 2 2  | \nos                    | \nos                  | \meh                | 1 1 1  | \yes               | \nos                    | \nos                  | \nos                     | \meh               |
| P09 | 1 4 1 1 1                  | 1 1    | \yes                 | \yes                   | 1 1    | \yes                   | \nos                    | 1 1 1  | \yes                    | \yes                  | \yes                | 1 2 1  | \yes               | \yes                    | \yes                  | \yes                     | \yes               |
| P10 | 1 5 1 1 5                  | 1 1    | \yes                 | \yes                   | 1 1    | \yes                   | \nos                    | 1 1 1  | \yes                    | \nos                  | \yes                | 1 1 1  | \yes               | \yes                    | \nos                  | \err                     | \err               |
| P11 | 1 1 1 1 2                  | 1 1    | \yes                 | \yes                   | 2 1    | \yes                   | \yes                    | 1 1 1  | \yes                    | \yes                  | \yes                | 1 1 2  | \yes               | \yes                    | \yes                  | \yes                     | \yes               |

\vspace{0.3cm}
\centering

Below the task names are the participants' responses to questions on a Likert
scale from 1 to 5 (see Appendix \ref{appendix:likert}).

| \yes | = | Successful |   | \meh | = | Partly successful |   | \nos | = | Not successful |   | \err | = | Mistake |

#+LATEX: \end{sidewaystable}

\clearpage

*** User Study Handout
<<appendix:handout>>

#+LATEX: \includepdf[pages=-]{userstudy.pdf}

** Footnotes

[fn:keybase] https://keybase.io
[fn:keybase-eternity] https://keybase.io/docs/server_security/merkle_root_in_bitcoin_blockchain

[fn:twitter] https://twitter.com

[fn:github] https://github.com

[fn:reddit] https://reddit.com

[fn:stackexchange] https://stackexchange.com
[fn:stackoverflow] https://stackoverflow.com

[fn:keybase-subreddit] http://www.reddit.com/r/KeybaseProofs/

[fn:sks-keyservers] http://pool.sks-keyservers.net/
[fn:pgp-global-dir] https://keyserver.pgp.com/

[fn:symantec] https://www.pgp.com

[fn:monkeysphere] http://web.monkeysphere.info/

[fn:gnupg] https://gnupg.org

[fn:openkeychain] http://openkeychain.org
[fn:r2mail2] http://r2mail2.com

[fn:twitter-api] https://dev.twitter.com/rest/public

[fn:minidns] https://github.com/rtreffer/minidns

[fn:nodejs] https://nodejs.org/

[fn:startssl] http://linux.startcom.org/?lang=en&app=14&rel=10

[fn:perspectives] http://perspectives-project.org/

[fn:textsecure] https://whispersystems.org/

[fn:debian] http://debian.org
[fn:heise] http://heise.de

[fn:whatwg-whitelist] https://html.spec.whatwg.org/\#whitelisted-scheme

[fn:symantecpgp] http://www.symantec.com/desktop-email-encryption/

[fn:KGPG] https://utils.kde.org/projects/kgpg/
[fn:seahorse] https://wiki.gnome.org/Seahorse
[fn:enigmail] https://www.enigmail.net/home/index.php
[fn:gpgmail] https://gpgtools.org/
[fn:gpg4o] https://www.giepa.de/products/gpg4o/?lang=en

[fn:bouncycastle] https://www.bouncycastle.org/
